<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Photo Gallery - Shopping Cart</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            opacity: 0.9;
            z-index: -1;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        /* Header Styles */
        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 40px;
            border-radius: 20px;
            margin-bottom: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.15), 0 0 0 1px rgba(255,255,255,0.2);
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, #667eea, transparent);
            animation: shimmer 3s infinite;
        }

        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .header h1 {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 15px;
            font-size: 2.8rem;
            font-weight: 700;
            letter-spacing: -0.02em;
        }

        .header p {
            color: #64748b;
            font-size: 1.2rem;
            font-weight: 500;
            opacity: 0.8;
        }

        /* Pricing Info Banner */
        .pricing-banner {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.95) 0%, rgba(118, 75, 162, 0.95) 100%);
            color: white;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 30px;
            text-align: center;
            font-size: 1.1rem;
            font-weight: 600;
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3);
            display: none;
        }

        .pricing-banner.show {
            display: block;
            animation: slideDown 0.5s ease;
        }

        /* Enhanced pricing mode visual indicators */
        .pricing-banner.free-mode {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.95) 0%, rgba(101, 163, 13, 0.95) 100%);
        }

        .pricing-banner.paid-mode {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.95) 0%, rgba(185, 28, 28, 0.95) 100%);
        }

        .pricing-banner.freemium-mode.freemium-free {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.95) 0%, rgba(34, 197, 94, 0.95) 100%);
        }

        .pricing-banner.freemium-mode.freemium-paid {
            background: linear-gradient(135deg, rgba(245, 101, 101, 0.95) 0%, rgba(251, 146, 60, 0.95) 100%);
        }

        .pricing-banner.bulk-mode {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.95) 0%, rgba(124, 58, 237, 0.95) 100%);
        }

        .pricing-banner.rate-limited {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Gallery Actions */
        .gallery-actions {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            padding: 25px;
            border-radius: 18px;
            margin-bottom: 35px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1), 0 0 0 1px rgba(255,255,255,0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
            position: sticky;
            top: 20px;
            z-index: 10;
        }

        .photo-count {
            font-weight: 700;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .photo-count::before {
            content: 'üì∏';
            font-size: 1.5rem;
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .select-all-btn {
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 12px;
            font-weight: 700;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 8px 25px rgba(139, 92, 246, 0.3);
        }

        .select-all-btn:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 12px 35px rgba(139, 92, 246, 0.4);
        }

        /* Gallery Grid */
        .gallery-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 25px;
            margin-bottom: 40px;
            padding: 0 5px;
        }

        /* Photo Card */
        .photo-card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1), 0 0 0 1px rgba(255,255,255,0.2);
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            cursor: pointer;
            position: relative;
        }

        .photo-card.in-cart {
            box-shadow: 0 10px 40px rgba(102, 126, 234, 0.3), 0 0 0 3px rgba(102, 126, 234, 0.5);
        }

        .photo-card:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 0 25px 60px rgba(0,0,0,0.15), 0 0 0 1px rgba(102, 126, 234, 0.1);
        }

        .photo-wrapper {
            position: relative;
            width: 100%;
            overflow: hidden;
            aspect-ratio: 4/3;
            background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
        }

        .photo-wrapper img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .photo-card:hover .photo-wrapper img {
            transform: scale(1.08) rotate(0.5deg);
        }

        /* Removed redundant cart indicator - button state handles this */

        /* Price Badge */
        .price-badge {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 8px 15px;
            border-radius: 25px;
            font-weight: 700;
            font-size: 0.95rem;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            z-index: 10;
        }

        .price-badge.free {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
        }

        .price-badge.paid {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
        }

        /* Photo Info */
        .photo-info {
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            position: relative;
            z-index: 2;
        }

        .photo-filename {
            font-weight: 700;
            color: #2d3748;
            font-size: 1.1rem;
            letter-spacing: -0.01em;
            line-height: 1.3;
            margin: 0;
        }

        .photo-actions {
            display: flex;
            gap: 10px;
        }

        .photo-btn {
            flex: 1;
            padding: 12px 18px;
            border: none;
            border-radius: 12px;
            font-size: 0.95rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            overflow: hidden;
        }

        .add-to-cart-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .add-to-cart-btn:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }

        .add-to-cart-btn.in-cart {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            box-shadow: 0 4px 15px rgba(245, 158, 11, 0.3);
        }

        .add-to-cart-btn.in-cart:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 8px 25px rgba(245, 158, 11, 0.4);
        }

        .download-btn {
            background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(72, 187, 120, 0.3);
        }

        .download-btn:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 8px 25px rgba(72, 187, 120, 0.4);
        }

        .download-btn.immediate.free {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.3);
        }

        .download-btn.immediate.free:hover {
            box-shadow: 0 8px 25px rgba(16, 185, 129, 0.4);
        }

        .download-btn.immediate.free.quota-exhausted {
            background: linear-gradient(135deg, #9ca3af 0%, #6b7280 100%);
            color: #f3f4f6;
            box-shadow: 0 4px 15px rgba(156, 163, 175, 0.3);
            cursor: not-allowed;
            opacity: 0.7;
        }

        .download-btn.immediate.free.quota-exhausted:hover {
            transform: none;
            box-shadow: 0 4px 15px rgba(156, 163, 175, 0.3);
        }

        .download-btn.immediate.paid {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            box-shadow: 0 4px 15px rgba(245, 158, 11, 0.3);
        }

        .download-btn.immediate.paid:hover {
            box-shadow: 0 8px 25px rgba(245, 158, 11, 0.4);
        }

        /* Floating Cart Icon */
        .floating-cart {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 70px;
            height: 70px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 30px;
            cursor: pointer;
            box-shadow: 0 10px 40px rgba(102, 126, 234, 0.5), 0 0 0 3px rgba(255,255,255,0.3);
            transition: all 0.3s ease;
            z-index: 1000;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 10px 40px rgba(102, 126, 234, 0.5), 0 0 0 3px rgba(255,255,255,0.3); }
            50% { box-shadow: 0 10px 40px rgba(102, 126, 234, 0.7), 0 0 0 6px rgba(255,255,255,0.1); }
            100% { box-shadow: 0 10px 40px rgba(102, 126, 234, 0.5), 0 0 0 3px rgba(255,255,255,0.3); }
        }

        .floating-cart:hover {
            transform: scale(1.1);
            box-shadow: 0 15px 50px rgba(102, 126, 234, 0.6), 0 0 0 3px rgba(255,255,255,0.4);
        }

        .cart-count {
            position: absolute;
            top: -5px;
            right: -5px;
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: 700;
            box-shadow: 0 4px 15px rgba(239, 68, 68, 0.5);
        }

        /* Cart Drawer */
        .cart-drawer {
            position: fixed;
            top: 0;
            right: -450px;
            width: 450px;
            height: 100%;
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(20px);
            box-shadow: -10px 0 50px rgba(0,0,0,0.2);
            transition: right 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 2000;
            display: flex;
            flex-direction: column;
        }

        .cart-drawer.open {
            right: 0;
        }

        .cart-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(5px);
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            z-index: 1999;
        }

        .cart-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .cart-header {
            padding: 25px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .cart-title {
            font-size: 1.5rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .close-cart {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 20px;
        }

        .close-cart:hover {
            background: rgba(255,255,255,0.3);
            transform: scale(1.1);
        }

        .cart-items {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .cart-empty {
            text-align: center;
            padding: 60px 20px;
            color: #94a3b8;
        }

        .cart-empty-icon {
            font-size: 60px;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        .cart-item {
            display: flex;
            gap: 15px;
            padding: 15px;
            background: rgba(248, 250, 252, 0.9);
            border-radius: 15px;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }

        .cart-item:hover {
            background: rgba(241, 245, 249, 1);
            transform: translateX(-5px);
        }

        .cart-item-image {
            width: 80px;
            height: 80px;
            border-radius: 10px;
            overflow: hidden;
            flex-shrink: 0;
        }

        .cart-item-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .cart-item-details {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .cart-item-name {
            font-weight: 600;
            color: #2d3748;
            margin-bottom: 5px;
            font-size: 0.95rem;
        }

        .cart-item-price {
            font-weight: 700;
            color: #667eea;
            font-size: 1.1rem;
        }

        .cart-item-remove {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
            border: none;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            align-self: center;
        }

        .cart-item-remove:hover {
            transform: scale(1.1);
            box-shadow: 0 5px 20px rgba(239, 68, 68, 0.4);
        }

        /* Cart Footer */
        .cart-footer {
            padding: 20px;
            background: rgba(248, 250, 252, 0.95);
            border-top: 1px solid rgba(226, 232, 240, 0.8);
        }

        .cart-total {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: white;
            border-radius: 12px;
        }

        .cart-total-label {
            font-weight: 600;
            color: #64748b;
            font-size: 1.1rem;
        }

        .cart-total-amount {
            font-weight: 700;
            font-size: 1.5rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .cart-actions {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .checkout-btn {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border: none;
            padding: 18px;
            border-radius: 12px;
            font-weight: 700;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 8px 25px rgba(16, 185, 129, 0.3);
        }

        .checkout-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 12px 35px rgba(16, 185, 129, 0.4);
        }

        .checkout-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .clear-cart-btn {
            background: rgba(239, 68, 68, 0.1);
            color: #dc2626;
            border: 2px solid #dc2626;
            padding: 12px;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .clear-cart-btn:hover {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
            transform: translateY(-1px);
        }

        /* Client Email Modal */
        .email-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(10px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 3000;
        }

        .email-modal.show {
            display: flex;
        }

        .email-modal-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        .email-modal h2 {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            font-size: 1.8rem;
        }

        .email-modal p {
            color: #64748b;
            margin-bottom: 30px;
            font-size: 1.05rem;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #475569;
        }

        .form-group input {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .form-group input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .form-actions {
            display: flex;
            gap: 12px;
            margin-top: 30px;
        }

        .form-actions button {
            flex: 1;
            padding: 14px;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .submit-email {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .cancel-email {
            background: #f1f5f9;
            color: #64748b;
        }

        /* Success Message */
        .success-message {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            padding: 20px 30px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(16, 185, 129, 0.4);
            display: none;
            align-items: center;
            gap: 15px;
            z-index: 3000;
            animation: slideInRight 0.5s ease;
        }

        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .success-message.show {
            display: flex;
        }

        /* Loading States */
        .loading {
            text-align: center;
            padding: 60px 40px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.1);
            margin: 40px 0;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 5px solid rgba(102, 126, 234, 0.1);
            border-top: 5px solid #667eea;
            border-radius: 50%;
            animation: spin 1.2s cubic-bezier(0.68, -0.55, 0.265, 1.55) infinite;
            margin: 0 auto 25px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Download Manager */
        .download-queue {
            position: fixed;
            bottom: 100px;
            right: 30px;
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.15);
            max-width: 400px;
            display: none;
            z-index: 999;
        }

        .download-queue.show {
            display: block;
            animation: slideUp 0.5s ease;
        }

        @keyframes slideUp {
            from {
                transform: translateY(100%);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .download-queue-title {
            font-weight: 700;
            color: #2d3748;
            margin-bottom: 15px;
            font-size: 1.1rem;
        }

        .download-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: #f8fafc;
            border-radius: 8px;
            margin-bottom: 10px;
        }

        .download-progress {
            width: 100%;
            height: 4px;
            background: #e2e8f0;
            border-radius: 2px;
            overflow: hidden;
            margin-top: 5px;
        }

        .download-progress-bar {
            height: 100%;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            transition: width 0.3s ease;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            body {
                padding: 15px;
            }

            .gallery-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .cart-drawer {
                width: 100%;
                right: -100%;
            }

            .floating-cart {
                width: 60px;
                height: 60px;
                font-size: 25px;
            }

            .header {
                padding: 30px 25px;
            }

            .header h1 {
                font-size: 2.2rem;
            }

            .gallery-actions {
                flex-direction: column;
                text-align: center;
            }

            .action-buttons {
                width: 100%;
                flex-direction: column;
            }

            .select-all-btn {
                width: 100%;
            }
        }

        @media (max-width: 480px) {
            .header h1 {
                font-size: 1.8rem;
            }

            .cart-drawer {
                padding-top: env(safe-area-inset-top);
            }
        }

        /* Error Styles */
        .error {
            background: linear-gradient(135deg, rgba(254, 215, 215, 0.9) 0%, rgba(252, 129, 129, 0.1) 100%);
            backdrop-filter: blur(10px);
            color: #c53030;
            padding: 30px;
            border-radius: 18px;
            text-align: center;
            margin-bottom: 30px;
            border: 1px solid rgba(197, 48, 48, 0.2);
            box-shadow: 0 10px 40px rgba(197, 48, 48, 0.1);
        }

        /* Quota Display Styles */
        .quota-info {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.1) 0%, rgba(147, 51, 234, 0.05) 100%);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(59, 130, 246, 0.2);
            border-radius: 12px;
            padding: 15px;
            margin: 15px 20px;
            font-size: 14px;
        }

        .quota-text {
            color: #374151;
            font-weight: 500;
            margin-bottom: 8px;
            text-align: center;
        }

        .quota-progress {
            background: rgba(156, 163, 175, 0.2);
            border-radius: 8px;
            height: 8px;
            overflow: hidden;
            position: relative;
        }

        .quota-bar {
            height: 100%;
            border-radius: 8px;
            transition: width 0.3s ease, background 0.3s ease;
            position: relative;
        }

        .quota-bar.quota-good {
            background: linear-gradient(90deg, #10b981 0%, #34d399 100%);
        }

        .quota-bar.quota-medium {
            background: linear-gradient(90deg, #3b82f6 0%, #60a5fa 100%);
        }

        .quota-bar.quota-warning {
            background: linear-gradient(90deg, #f59e0b 0%, #fbbf24 100%);
        }

        .quota-bar.quota-critical {
            background: linear-gradient(90deg, #ef4444 0%, #f87171 100%);
        }

        .quota-bar.quota-exhausted {
            background: linear-gradient(90deg, #dc2626 0%, #ef4444 100%);
            animation: flash 1s infinite;
        }

        .quota-bar.quota-unlimited {
            background: linear-gradient(90deg, #10b981 0%, #34d399 100%);
        }

        .quota-bar.quota-freemium {
            background: linear-gradient(90deg, #22c55e 0%, #3b82f6 100%);
        }

        @keyframes flash {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.5; }
        }

        /* Progress Indicator Styles */
        .progress-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10000;
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            color: white;
            text-align: center;
            min-width: 300px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        .progress-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .progress-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid #3b82f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .progress-message {
            font-size: 16px;
            font-weight: 500;
            margin: 0;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6 0%, #1d4ed8 100%);
            transition: width 0.5s ease;
            border-radius: 4px;
        }

        /* Toast Notification Styles */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10001;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .toast {
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            gap: 12px;
            min-width: 300px;
            max-width: 500px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            animation: toastSlideIn 0.3s ease;
            border-left: 4px solid #3b82f6;
        }

        .toast-success {
            border-left-color: #22c55e;
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.9) 0%, rgba(21, 128, 61, 0.9) 100%);
        }

        .toast-error {
            border-left-color: #ef4444;
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.9) 0%, rgba(185, 28, 28, 0.9) 100%);
        }

        .toast-warning {
            border-left-color: #f59e0b;
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.9) 0%, rgba(217, 119, 6, 0.9) 100%);
        }

        .toast-rate-limit {
            border-left-color: #8b5cf6;
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.9) 0%, rgba(109, 40, 217, 0.9) 100%);
        }

        .toast-network-error {
            border-left-color: #06b6d4;
            background: linear-gradient(135deg, rgba(6, 182, 212, 0.9) 0%, rgba(8, 145, 178, 0.9) 100%);
        }

        .toast-quota-exceeded {
            border-left-color: #f97316;
            background: linear-gradient(135deg, rgba(249, 115, 22, 0.9) 0%, rgba(234, 88, 12, 0.9) 100%);
        }

        .toast-icon {
            font-size: 20px;
            flex-shrink: 0;
        }

        .toast-message {
            flex: 1;
            font-size: 14px;
            line-height: 1.4;
        }

        .toast-close {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            font-size: 18px;
            cursor: pointer;
            padding: 0;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease;
        }

        .toast-close:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        @keyframes toastSlideIn {
            from {
                opacity: 0;
                transform: translateX(100%);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .toast-fade-out {
            animation: toastFadeOut 0.3s ease forwards;
        }

        @keyframes toastFadeOut {
            from {
                opacity: 1;
                transform: translateX(0);
            }
            to {
                opacity: 0;
                transform: translateX(100%);
            }
        }

        /* Quota Modal Styles */
        .quota-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            backdrop-filter: blur(4px);
        }

        .quota-modal {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.25);
            border: 1px solid rgba(255, 255, 255, 0.2);
            overflow: hidden;
        }

        .quota-modal-header {
            background: linear-gradient(135deg, rgba(254, 215, 215, 0.8) 0%, rgba(252, 129, 129, 0.2) 100%);
            padding: 20px;
            text-align: center;
            border-bottom: 1px solid rgba(252, 129, 129, 0.2);
        }

        .quota-modal-header h3 {
            margin: 0;
            color: #c53030;
            font-size: 20px;
        }

        .quota-modal-body {
            padding: 25px;
            line-height: 1.6;
        }

        .quota-details {
            background: rgba(243, 244, 246, 0.5);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
        }

        .quota-details ul {
            margin: 10px 0 0 0;
            padding-left: 20px;
        }

        .quota-details li {
            margin: 5px 0;
        }

        .quota-modal-actions {
            padding: 20px;
            text-align: center;
            border-top: 1px solid rgba(243, 244, 246, 0.8);
        }

        .quota-modal-btn {
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.3);
        }

        .quota-modal-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(59, 130, 246, 0.4);
        }

        .empty-gallery {
            text-align: center;
            padding: 60px 40px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.1);
            margin: 40px 0;
        }

        /* Credit Status Banner */
        .credit-banner {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.95) 0%, rgba(37, 99, 235, 0.95) 100%);
            color: white;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 30px;
            text-align: center;
            font-size: 1.2rem;
            font-weight: 600;
            box-shadow: 0 10px 30px rgba(59, 130, 246, 0.3);
            display: none;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }

        .credit-banner.show {
            display: flex;
            animation: slideDown 0.5s ease;
        }

        .credit-banner.unlimited {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.95) 0%, rgba(22, 163, 74, 0.95) 100%);
        }

        .credit-banner.low-credits {
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.95) 0%, rgba(217, 119, 6, 0.95) 100%);
        }

        .credit-banner.no-credits {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.95) 0%, rgba(220, 38, 38, 0.95) 100%);
        }

        .credit-icon {
            font-size: 1.5rem;
        }

        /* Unlock All Photos Button */
        .unlock-all-btn {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 12px;
            font-weight: 700;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 8px 25px rgba(245, 158, 11, 0.3);
            margin-left: auto;
        }

        .unlock-all-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 35px rgba(245, 158, 11, 0.4);
        }

        /* Unlock Modal */
        .unlock-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(10px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 3000;
        }

        .unlock-modal.show {
            display: flex;
        }

        .unlock-modal-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            text-align: center;
        }

        .unlock-modal h2 {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 15px;
            font-size: 2rem;
        }

        .unlock-modal p {
            color: #64748b;
            margin-bottom: 30px;
            font-size: 1.1rem;
        }

        .unlock-price {
            font-size: 2.5rem;
            font-weight: 700;
            color: #667eea;
            margin: 20px 0;
        }

        .unlock-modal-actions {
            display: flex;
            gap: 15px;
            margin-top: 30px;
        }

        .unlock-confirm-btn {
            flex: 1;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border: none;
            padding: 15px;
            border-radius: 12px;
            font-weight: 700;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .unlock-confirm-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(16, 185, 129, 0.4);
        }

        .unlock-cancel-btn {
            flex: 1;
            background: rgba(239, 68, 68, 0.1);
            color: #dc2626;
            border: 2px solid #dc2626;
            padding: 15px;
            border-radius: 12px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .unlock-cancel-btn:hover {
            background: #dc2626;
            color: white;
        }

        /* Hide cart UI elements for simple credit system */
        .floating-cart,
        .cart-drawer,
        .cart-overlay,
        .add-to-cart-btn,
        .select-all-btn {
            display: none !important;
        }

        /* Ensure download buttons are full width when cart is hidden */
        .photo-actions {
            display: block;
        }

        .download-btn {
            width: 100%;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1 id="galleryTitle">Loading Gallery...</h1>
            <p id="gallerySubtitle">Please wait while we load your photos</p>
        </div>

        <!-- Pricing Banner -->
        <div id="pricingBanner" class="pricing-banner">
            <span id="pricingInfo">Loading pricing information...</span>
        </div>

        <!-- Credit Status Banner -->
        <div id="creditBanner" class="credit-banner">
            <span class="credit-icon">üí≥</span>
            <span id="creditText">Loading credit status...</span>
            <button id="unlockAllBtn" class="unlock-all-btn" style="display: none;">
                Unlock All Photos
            </button>
        </div>

        <!-- Loading State -->
        <div id="loadingContainer" class="loading">
            <div class="loading-spinner"></div>
            <h3>Preparing Your Gallery</h3>
            <p>Loading beautiful memories...</p>
        </div>

        <!-- Error Container -->
        <div id="errorContainer" class="error" style="display: none;">
            <h2>Gallery Access Error</h2>
            <p id="errorMessage">Unable to access this gallery. Please check your link and try again.</p>
        </div>

        <!-- Gallery Actions -->
        <div id="galleryActions" class="gallery-actions" style="display: none;">
            <div class="photo-count" id="photoCount">0 photos</div>
            <div class="action-buttons">
                <button class="select-all-btn" id="selectAllBtn">
                    ‚ú® Select All Photos
                </button>
            </div>
        </div>

        <!-- Gallery Grid -->
        <div id="galleryGrid" class="gallery-grid"></div>

        <!-- Empty Gallery -->
        <div id="emptyGallery" class="empty-gallery" style="display: none;">
            <h2>No Photos Available</h2>
            <p>This gallery doesn't have any photos available yet. Please check back later.</p>
        </div>
    </div>

    <!-- Floating Cart Icon -->
    <div class="floating-cart" id="floatingCart" style="display: none;">
        üõí
        <span class="cart-count" id="cartCount">0</span>
    </div>

    <!-- Cart Overlay -->
    <div class="cart-overlay" id="cartOverlay"></div>

    <!-- Cart Drawer -->
    <div class="cart-drawer" id="cartDrawer">
        <div class="cart-header">
            <div class="cart-title">
                üõí Shopping Cart
            </div>
            <button class="close-cart" id="closeCart">‚úï</button>
        </div>

        <!-- Quota Information Display -->
        <div class="quota-info" id="quotaInfo" style="display: none;">
            <div class="quota-text" id="quotaText">Loading quota...</div>
            <div class="quota-progress" id="quotaProgress">
                <div class="quota-bar quota-good" id="quotaBar"></div>
            </div>
        </div>

        <div class="cart-items" id="cartItems">
            <div class="cart-empty">
                <div class="cart-empty-icon">üõí</div>
                <h3>Your cart is empty</h3>
                <p>Add photos to start your collection</p>
            </div>
        </div>
        <div class="cart-footer">
            <div class="cart-total">
                <span class="cart-total-label">Total:</span>
                <span class="cart-total-amount" id="cartTotal">$0.00</span>
            </div>
            <div class="cart-actions">
                <button class="checkout-btn" id="checkoutBtn" disabled>
                    Proceed to Checkout
                </button>
                <button class="clear-cart-btn" id="clearCartBtn">
                    Clear Cart
                </button>
            </div>
        </div>
    </div>

    <!-- Client Email Modal -->
    <div class="email-modal" id="emailModal">
        <div class="email-modal-content">
            <h2>Complete Your Order</h2>
            <p>Please provide your email to receive your photos and receipt</p>
            <form id="emailForm">
                <div class="form-group">
                    <label for="clientEmail">Email Address *</label>
                    <input type="email" id="clientEmail" name="email" required placeholder="your@email.com">
                </div>
                <div class="form-group">
                    <label for="clientName">Name (optional)</label>
                    <input type="text" id="clientName" name="name" placeholder="Your Name">
                </div>
                <div class="form-actions">
                    <button type="submit" class="submit-email">Continue to Payment</button>
                    <button type="button" class="cancel-email" id="cancelEmail">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Unlock All Photos Modal -->
    <div class="unlock-modal" id="unlockModal">
        <div class="unlock-modal-content">
            <h2>Unlock All Photos</h2>
            <p>Get unlimited downloads for all photos in this gallery</p>
            <div class="unlock-price" id="unlockPrice">$0.00</div>
            <p>One-time payment ‚Ä¢ Instant access ‚Ä¢ Download unlimited times</p>
            <div class="unlock-modal-actions">
                <button class="unlock-confirm-btn" id="unlockConfirmBtn">
                    Unlock Now
                </button>
                <button class="unlock-cancel-btn" id="unlockCancelBtn">
                    Cancel
                </button>
            </div>
        </div>
    </div>

    <!-- Success Message -->
    <div class="success-message" id="successMessage">
        <span>‚úì</span>
        <span id="successText">Photo added to cart!</span>
    </div>

    <!-- Download Queue -->
    <div class="download-queue" id="downloadQueue">
        <div class="download-queue-title">Downloads in Progress</div>
        <div id="downloadQueueItems"></div>
    </div>

    <!-- Include Screenshot Protection Script -->
    <script src="/static/js/screenshot-protection.js"></script>

    <script>
        // Immediately show JavaScript is running
        document.addEventListener('DOMContentLoaded', function() {
            // Add visual indicator that JavaScript is running
            const indicator = document.createElement('div');
            indicator.style.cssText = 'position:fixed;top:10px;right:10px;background:green;color:white;padding:10px;z-index:9999;border-radius:5px;';
            indicator.textContent = '‚úÖ JavaScript is running!';
            document.body.appendChild(indicator);
        });

        // Add immediate debugging
        console.log('üöÄ Gallery JavaScript starting to load...');

        // Add error handler to catch any issues
        window.addEventListener('error', function(event) {
            console.error('‚ùå JavaScript Error:', event.error);
            console.error('‚ùå Error at:', event.filename, 'Line:', event.lineno, 'Col:', event.colno);
            // Also display error on page
            const errorDiv = document.getElementById('errorContainer');
            if (errorDiv) {
                errorDiv.style.display = 'block';
                document.getElementById('errorMessage').textContent = 'JavaScript Error: ' + event.error.message;
            }
        });

        // ClientGalleryCart Class
        class ClientGalleryCart {
            constructor() {
                this.cart = [];
                this.entitlements = [];
                this.policy = null;
                this.sessionData = null;
                this.photos = [];
                this.galleryToken = null;
                this.clientEmail = null;
                this.clientName = null;
                this.downloadQueue = [];
                this.uniqueVisitorId = null;
                this.cachedGalleryClientKey = null;
                this.currentQuota = null; // Track current quota status

                // Initialize from URL - support both path and query parameter patterns
                const urlParams = new URLSearchParams(window.location.search);
                const pathParts = window.location.pathname.split('/');

                // Try to get token from URL parameters first (e.g., ?token=abc123)
                this.galleryToken = urlParams.get('token');

                // If no token in parameters, extract from URL path 
                if (!this.galleryToken) {
                    // Support patterns like /gallery/token or /g/token
                    const lastPathSegment = pathParts[pathParts.length - 1];
                    if (lastPathSegment && lastPathSegment !== 'client-gallery.html' && lastPathSegment !== '') {
                        this.galleryToken = lastPathSegment;
                    }
                }

                console.log('üîë Extracted gallery token:', this.galleryToken ? 'Found' : 'Not found', 'from', 
                           urlParams.get('token') ? 'URL parameters' : 'URL path');

                // Check for success/cancel from Stripe
                this.checkoutStatus = urlParams.get('status');
                this.sessionId = urlParams.get('session_id');

                // Bind methods
                this.init = this.init.bind(this);
                this.loadCart = this.loadCart.bind(this);
                this.saveCart = this.saveCart.bind(this);
                this.addToCart = this.addToCart.bind(this);
                this.removeFromCart = this.removeFromCart.bind(this);
                this.updateCartUI = this.updateCartUI.bind(this);
                this.calculateTotal = this.calculateTotal.bind(this);
                this.proceedToCheckout = this.proceedToCheckout.bind(this);
                this.loadEntitlements = this.loadEntitlements.bind(this);
                this.downloadPhoto = this.downloadPhoto.bind(this);
                this.handleCheckoutReturn = this.handleCheckoutReturn.bind(this);
                this.updatePricingBanner = this.updatePricingBanner.bind(this);
                this.calculatePrice = this.calculatePrice.bind(this);
                this.renderPhotoCard = this.renderPhotoCard.bind(this);

                // Initialize
                this.init();
            }

            /**
             * Get the correct API base URL for both localhost development and production
             * For localhost development: use current origin (e.g., http://localhost:5000)
             * For production published galleries: use main domain (https://photomanagementsystem.com)
             */
            getApiBaseUrl() {
                const hostname = window.location.hostname;

                // For localhost development, use current origin
                if (hostname === 'localhost' || hostname === '127.0.0.1' || hostname.includes('replit')) {
                    return window.location.origin;
                }

                // For production published galleries on subdomains, use main domain
                return 'https://photomanagementsystem.com';
            }

            async init() {
                console.log('üõí Initializing ClientGalleryCart...');

                // CRITICAL FIX: Generate unique visitor ID for freemium quota tracking
                // Must be done FIRST before any API calls that use getClientKey()
                this.generateUniqueVisitorId();
                console.log('üÜî Visitor ID initialized:', this.uniqueVisitorId);

                // Initialize screenshot protection system
                this.initializeProtection();

                // Load saved cart and client info
                this.loadCart();
                this.loadClientInfo();

                // Setup UI event listeners
                this.setupEventListeners();

                // Load gallery data
                await this.loadGallery();

                // FREEMIUM FIX: Generate and cache gallery-based client key for freemium mode
                if (this.policy && this.policy.mode === 'freemium' && this.galleryToken && this.sessionData) {
                    this.cachedGalleryClientKey = await this.generateGalleryClientKey(this.galleryToken, this.sessionData.id);
                    console.log(`üîë Cached gallery client key for freemium mode: ${this.cachedGalleryClientKey}`);
                }

                // Recalculate cart prices based on correct freemium logic
                // This fixes any cart items that were saved with incorrect prices
                if (this.cart.length > 0 && this.policy) {
                    console.log('üõí Recalculating cart prices after loading gallery policy...');
                    this.recalculatePrices();
                }

                // Handle checkout return
                if (this.checkoutStatus) {
                    await this.handleCheckoutReturn();
                }

                // Load entitlements to check for already purchased photos
                // For freemium galleries, we need to load entitlements even without client email
                // to properly show download buttons for unpurchased photos
                await this.loadEntitlements();

                // Load initial quota status
                await this.loadQuotaStatus();

                // Load simple credit status for simple credit system
                await this.fetchCreditStatus();

                // Synchronize cart state with backend after session is fully loaded
                // This ensures cart consistency between localStorage and server
                console.log('üîÑ Synchronizing cart state with backend...');
                const syncResult = await this.reconcileCart();
                if (syncResult.success) {
                    console.log('‚úÖ Cart synchronization complete:', syncResult.changes);
                    if (syncResult.changes.itemsAdded > 0 || syncResult.changes.itemsRemoved > 0) {
                        this.showSuccess(`Cart synchronized: ${syncResult.changes.itemsAdded} added, ${syncResult.changes.itemsRemoved} removed`);
                    }
                } else {
                    console.warn('‚ö†Ô∏è Cart synchronization failed, using local state:', syncResult.message || syncResult.error);
                }

                // Initialize real-time gallery updates after everything is loaded
                this.initializeRealTimeUpdates();
            }

            initializeRealTimeUpdates() {
                if (!this.galleryToken) {
                    console.warn('‚ö†Ô∏è No gallery token available for real-time updates');
                    return;
                }

                try {
                    console.log('üîÑ Initializing real-time gallery updates...');

                    // Create EventSource connection to SSE endpoint
                    this.eventSource = new EventSource(`${this.getApiBaseUrl()}/api/gallery/events?token=${this.galleryToken}`);

                    this.eventSource.onopen = (event) => {
                        console.log('‚úÖ Real-time gallery updates connected');
                    };

                    // Listen for connection confirmation
                    this.eventSource.addEventListener('connected', (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            console.log('üì° SSE connection confirmed:', data);
                        } catch (error) {
                            console.error('‚ùå Error parsing connection event:', error);
                        }
                    });

                    // Listen for photo updates (server sends 'photos_updated' events)
                    this.eventSource.addEventListener('photos_updated', (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            console.log('üì° Photos updated event received:', data);
                            this.handlePhotosAdded(data);
                        } catch (error) {
                            console.error('‚ùå Error parsing photos updated event:', error);
                        }
                    });

                    // Listen for gallery refresh events
                    this.eventSource.addEventListener('gallery_refresh', (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            console.log('üì° Gallery refresh event received:', data);
                            this.refreshGallery();
                        } catch (error) {
                            console.error('‚ùå Error parsing gallery refresh event:', error);
                        }
                    });

                    // Listen for heartbeat events (keep-alive)
                    this.eventSource.addEventListener('heartbeat', (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            console.log('üíì SSE heartbeat received:', data.timestamp);
                        } catch (error) {
                            console.error('‚ùå Error parsing heartbeat event:', error);
                        }
                    });

                    this.eventSource.onerror = (event) => {
                        console.error('‚ùå Real-time gallery updates connection error:', event);

                        // Attempt to reconnect after a delay
                        setTimeout(() => {
                            if (this.eventSource.readyState === EventSource.CLOSED) {
                                console.log('üîÑ Attempting to reconnect real-time updates...');
                                this.initializeRealTimeUpdates();
                            }
                        }, 5000);
                    };
                } catch (error) {
                    console.error('‚ùå Failed to initialize real-time updates:', error);
                }
            }

            async handlePhotosAdded(data) {
                try {
                    const newPhotosCount = data.newPhotosCount || 0;
                    console.log(`üÜï ${newPhotosCount} new photos added to gallery!`, data);

                    // Show a brief notification to the user
                    if (newPhotosCount > 0) {
                        this.showUpdateNotification(`${newPhotosCount} new photo${newPhotosCount > 1 ? 's' : ''} added!`);
                    }

                    // Refresh the gallery to show new photos
                    await this.refreshGallery();

                } catch (error) {
                    console.error('‚ùå Error handling photos added:', error);
                }
            }

            async refreshGallery() {
                try {
                    console.log('üîÑ Refreshing gallery with new photos...');

                    // Re-verify gallery access using unified API
                    const validateResponse = await this.validateUnifiedAccess();

                    if (validateResponse.success && validateResponse.data.session) {
                        const verifyData = validateResponse.data;
                        // Update photos array with new data
                        this.photos = verifyData.photos || [];
                        console.log(`üì∏ Gallery refreshed: now showing ${this.photos.length} photos`);

                        // Refresh the display
                        this.displayPhotos();

                        // Update UI elements that show photo count
                        const photoCountElements = document.querySelectorAll('.photo-count');
                        photoCountElements.forEach(element => {
                            element.textContent = `${this.photos.length} photo${this.photos.length !== 1 ? 's' : ''}`;
                        });

                        // If gallery was empty before, show gallery actions
                        if (this.photos.length > 0) {
                            document.getElementById('galleryActions').style.display = 'flex';
                            document.getElementById('floatingCart').style.display = 'flex';
                            document.getElementById('emptyGallery').style.display = 'none';
                        }
                    } else {
                        console.warn('‚ö†Ô∏è Failed to refresh gallery data');
                    }
                } catch (error) {
                    console.error('‚ùå Error refreshing gallery:', error);
                }
            }

            showUpdateNotification(message) {
                // Create or update notification element
                let notification = document.getElementById('realtimeNotification');
                if (!notification) {
                    notification = document.createElement('div');
                    notification.id = 'realtimeNotification';
                    notification.style.cssText = `
                        position: fixed;
                        top: 20px;
                        right: 20px;
                        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                        color: white;
                        padding: 15px 20px;
                        border-radius: 10px;
                        box-shadow: 0 8px 32px rgba(0,0,0,0.2);
                        z-index: 10000;
                        font-weight: 600;
                        opacity: 0;
                        transform: translateY(-20px);
                        transition: all 0.3s ease;
                    `;
                    document.body.appendChild(notification);
                }

                notification.textContent = message;

                // Show notification
                requestAnimationFrame(() => {
                    notification.style.opacity = '1';
                    notification.style.transform = 'translateY(0)';
                });

                // Hide notification after 3 seconds
                setTimeout(() => {
                    notification.style.opacity = '0';
                    notification.style.transform = 'translateY(-20px)';
                }, 3000);
            }

            // Clean up EventSource on page unload
            disconnectRealTimeUpdates() {
                if (this.eventSource) {
                    console.log('üîå Disconnecting real-time gallery updates');
                    this.eventSource.close();
                    this.eventSource = null;
                }
            }

            initializeProtection() {
                // Initialize screenshot protection if available
                if (window.ScreenshotProtection) {
                    this.protection = new ScreenshotProtection();
                    console.log('üõ°Ô∏è Screenshot protection initialized');
                } else {
                    console.warn('‚ö†Ô∏è Screenshot protection module not loaded');
                }
            }

            setupEventListeners() {
                // Cart toggle
                const floatingCart = document.getElementById('floatingCart');
                const closeCart = document.getElementById('closeCart');
                const cartOverlay = document.getElementById('cartOverlay');

                floatingCart?.addEventListener('click', () => this.openCart());
                closeCart?.addEventListener('click', () => this.closeCart());
                cartOverlay?.addEventListener('click', () => this.closeCart());

                // Cart actions
                document.getElementById('checkoutBtn')?.addEventListener('click', () => this.proceedToCheckout());
                document.getElementById('clearCartBtn')?.addEventListener('click', () => this.clearCart());

                // Select all button
                document.getElementById('selectAllBtn')?.addEventListener('click', () => this.selectAllPhotos());

                // Email modal
                document.getElementById('emailForm')?.addEventListener('submit', (e) => this.handleEmailSubmit(e));
                document.getElementById('cancelEmail')?.addEventListener('click', () => this.closeEmailModal());

                // Unlock All Photos modal
                document.getElementById('unlockAllBtn')?.addEventListener('click', () => this.showUnlockModal());
                document.getElementById('unlockConfirmBtn')?.addEventListener('click', () => this.unlockAllPhotos());
                document.getElementById('unlockCancelBtn')?.addEventListener('click', () => this.hideUnlockModal());

                // Mobile swipe to close cart
                let startX = 0;
                const cartDrawer = document.getElementById('cartDrawer');

                cartDrawer?.addEventListener('touchstart', (e) => {
                    startX = e.touches[0].clientX;
                });

                cartDrawer?.addEventListener('touchend', (e) => {
                    const endX = e.changedTouches[0].clientX;
                    if (endX - startX > 100) { // Swipe right
                        this.closeCart();
                    }
                });
            }

            async loadGallery() {
                try {
                    console.log('üì∏ Loading gallery with token:', this.galleryToken);

                    // Use new unified API for gallery access validation
                    const validateResponse = await this.validateUnifiedAccess();

                    if (!validateResponse.success) {
                        console.error('‚ùå Gallery access validation failed:', validateResponse.error);
                        this.showError(validateResponse.error || 'Unable to access gallery');
                        return;
                    }

                    const verifyData = validateResponse.data;
                    console.log('üîç Unified API Response received:', verifyData);
                    console.log('üîç API Response data structure:', JSON.stringify(verifyData, null, 2));

                    if (!verifyData.success || !verifyData) {
                        throw new Error(verifyData?.error || 'Gallery access denied');
                    }

                    // Check if we have success and session data
                    if (!verifyData.success || !verifyData.session) {
                        console.error('‚ùå Invalid API response structure:', verifyData);
                        throw new Error('Invalid gallery response structure');
                    }

                    const sessionData = verifyData.session;
                    console.log('üîç Session data extracted:', sessionData);

                    // Extract session data from the response (photos are included)
                    this.sessionData = {
                        id: verifyData.sessionId || sessionData.id,
                        clientName: sessionData.clientName,
                        sessionName: sessionData.sessionName || 'Photo Gallery',
                        sessionDate: sessionData.sessionDate || new Date().toISOString(),
                        downloadEnabled: sessionData.downloadEnabled,
                        pricingModel: sessionData.pricingModel,
                        downloadMax: sessionData.downloadMax,
                        pricePerDownload: sessionData.pricePerDownload,
                        freeDownloads: sessionData.freeDownloads
                    };
                    console.log('‚úÖ Gallery verified:', this.sessionData);

                    // Load policy from session data to enable freemium mode
                    await this.loadPolicy();
                    console.log('üîß Policy loaded:', this.policy);

                    // FIX: Photos are in verifyData.photos, not sessionData.photos
                    this.photos = verifyData.photos || [];
                    console.log(`üì∏ Photos array found:`, this.photos);
                    console.log(`üì∏ Loaded ${this.photos.length} photos`);

                    // Debug each photo
                    this.photos.forEach((photo, index) => {
                        console.log(`üì∏ Photo ${index + 1}:`, {
                            id: photo.id,
                            filename: photo.filename,
                            url: photo.url,
                            hasUrl: !!photo.url,
                            hasFilename: !!photo.filename
                        });
                    });

                    // Get download policy
                    await this.loadPolicy();

                    // Update UI
                    this.updateGalleryUI();
                    await this.updatePricingBanner();
                    this.displayPhotos();

                    // Hide loading, show gallery
                    document.getElementById('loadingContainer').style.display = 'none';
                    if (this.photos.length > 0) {
                        console.log('‚úÖ Showing gallery with photos');
                        document.getElementById('galleryActions').style.display = 'flex';
                        document.getElementById('floatingCart').style.display = 'flex';
                    } else {
                        console.warn('‚ö†Ô∏è No photos found, showing empty gallery');
                        document.getElementById('emptyGallery').style.display = 'block';
                    }

                } catch (error) {
                    console.error('‚ùå Error loading gallery:', error);
                    console.error('‚ùå Error stack:', error.stack);
                    console.error('‚ùå Token being used:', this.galleryToken);

                    // CRITICAL DEBUG: Try to force the gallery to work even with errors
                    console.log('üîÑ ATTEMPTING EMERGENCY GALLERY RECOVERY...');

                    try {
                        // Make one more direct API call using unified endpoint
                        const emergencyResponse = await this.validateUnifiedAccess();

                        console.log('üö® EMERGENCY RESPONSE:', emergencyResponse);
                        const emergencyData = emergencyResponse.data;

                        if (emergencyData.success && emergencyData.session) {
                            console.log('‚úÖ EMERGENCY RECOVERY SUCCESS - Processing data...');
                            this.sessionData = emergencyData.session;
                            this.photos = emergencyData.photos || [];

                            // Set freemium policy directly from API response
                            this.policy = {
                                mode: 'freemium',
                                pricePerPhoto: parseFloat(this.sessionData.pricePerDownload || 4.66),
                                freeCount: parseInt(this.sessionData.freeDownloads || 2),
                                screenshotProtection: true
                            };

                            console.log('‚úÖ EMERGENCY POLICY SET:', this.policy);
                            console.log('‚úÖ EMERGENCY PHOTOS LOADED:', this.photos.length);

                            // Force render the gallery
                            this.displayPhotos();
                            document.getElementById('loadingContainer').style.display = 'none';
                            if (this.photos.length > 0) {
                                document.getElementById('galleryActions').style.display = 'flex';
                                document.getElementById('floatingCart').style.display = 'flex';
                            }

                            console.log('üéâ EMERGENCY RECOVERY COMPLETE - Gallery should now show freemium buttons!');
                            return; // Exit successful recovery
                        }
                    } catch (emergencyError) {
                        console.error('üí• EMERGENCY RECOVERY FAILED:', emergencyError);
                    }

                    this.showError(error.message);

                    // Hide loading and show error
                    document.getElementById('loadingContainer').style.display = 'none';
                    document.getElementById('errorContainer').style.display = 'block';
                }
            }

            async loadPolicy() {
                // Policy information is now included in the session data from verification
                // Build policy object from session data
                if (this.sessionData) {
                    // Map pricing model to policy mode
                    let mode = 'free';
                    const pricingModel = this.sessionData.pricingModel || this.sessionData.pricing_model;
                    console.log('üîç Pricing model from session data:', pricingModel);
                    switch (pricingModel) {
                        case 'free':
                            mode = 'free';
                            break;
                        case 'paid':
                        case 'fixed':
                            mode = 'fixed';
                            break;
                        case 'freemium':
                            mode = 'freemium';
                            break;
                        case 'per_photo':
                            mode = 'per_photo';
                            break;
                        default:
                            mode = 'free';
                    }

                    this.policy = {
                        mode: mode,
                        pricePerPhoto: parseFloat(this.sessionData.pricePerDownload || this.sessionData.price_per_download || 0) || 0,
                        freeCount: parseInt(this.sessionData.freeDownloads || this.sessionData.free_downloads || 0, 10) || 0,
                        screenshotProtection: true // Enable by default for previews
                    };

                    console.log('üìã Built policy from session data:', this.policy);
                    console.log('üêõ DEBUG: Raw session data for policy:', {
                        pricingModel: pricingModel,
                        pricePerDownload: this.sessionData.pricePerDownload,
                        freeDownloads: this.sessionData.freeDownloads,
                        parsedPricePerPhoto: this.policy.pricePerPhoto,
                        parsedFreeCount: this.policy.freeCount
                    });

                    // CRITICAL DEBUG: Make absolutely sure freemium is detected
                    if (pricingModel === 'freemium') {
                        console.log('‚úÖ‚úÖ‚úÖ FREEMIUM MODE CONFIRMED - Should show immediate download buttons!');
                        console.log('üì• First', this.policy.freeCount, 'photos should show FREE buttons');
                        console.log('üíµ Remaining photos should show $' + this.policy.pricePerPhoto.toFixed(2) + ' buttons');
                    } else {
                        console.log('‚ùå‚ùå‚ùå NOT IN FREEMIUM MODE - Will show Add to Cart buttons');
                        console.log('‚ùå Current mode:', mode, 'from pricingModel:', pricingModel);
                    }

                    // Update screenshot protection settings
                    if (this.protection && this.policy.screenshotProtection !== undefined) {
                        this.protection.toggleProtection(this.policy.screenshotProtection);
                        console.log(`üõ°Ô∏è Screenshot protection ${this.policy.screenshotProtection ? 'enabled' : 'disabled'} from policy`);
                    }
                } else {
                    // Fallback if no session data
                    this.policy = { mode: 'free', screenshotProtection: true };
                    console.log('üìã Using fallback free policy');
                }
            }

            updateGalleryUI() {
                // Update header
                document.getElementById('galleryTitle').textContent = 
                    this.sessionData.sessionName || 'Photo Gallery';
                document.getElementById('gallerySubtitle').textContent = 
                    `${this.sessionData.clientName || ''} - ${new Date(this.sessionData.sessionDate).toLocaleDateString()}`;

                // Update photo count
                document.getElementById('photoCount').textContent = 
                    `${this.photos.length} photo${this.photos.length !== 1 ? 's' : ''}`;
            }

            updatePricingBanner() {
                const banner = document.getElementById('pricingBanner');
                const pricingInfo = document.getElementById('pricingInfo');

                if (!banner || !pricingInfo || !this.policy) {
                    console.log('üö´ Cannot update pricing banner - missing elements or policy');
                    return;
                }

                console.log(`üè∑Ô∏è Updating pricing banner for mode: ${this.policy.mode}`);

                // Reset classes
                banner.className = 'pricing-banner show';

                let bannerText = '';
                let bannerClass = '';

                switch (this.policy.mode) {
                    case 'free':
                        bannerText = 'üéâ All downloads are FREE! Click any photo to download instantly.';
                        bannerClass = 'free-mode';
                        console.log('üÜì Set FREE mode banner');
                        break;

                    case 'freemium':
                        const freeCount = parseInt(this.policy.freeCount) || 0;
                        const priceAfterFree = parseFloat(this.policy.pricePerPhoto) || 5.00;

                        if (freeCount > 0) {
                            bannerText = `‚≠ê First ${freeCount} downloads FREE, then $${priceAfterFree.toFixed(2)} each. Start downloading!`;
                            bannerClass = 'freemium-mode freemium-free';
                        } else {
                            bannerText = `üí∞ Downloads: $${priceAfterFree.toFixed(2)} per photo. Add to cart to purchase.`;
                            bannerClass = 'freemium-mode freemium-paid';
                        }
                        console.log(`üéÅ Set FREEMIUM mode banner: ${freeCount} free, $${priceAfterFree} paid`);
                        break;

                    case 'per_photo':
                    case 'fixed':
                    case 'paid':
                        const paidPrice = parseFloat(this.policy.pricePerPhoto) || 5.00;
                        bannerText = `üí∞ Premium downloads: $${paidPrice.toFixed(2)} per photo. Add to cart to purchase.`;
                        bannerClass = 'paid-mode';
                        console.log(`üíµ Set PAID mode banner: $${paidPrice} per photo`);
                        break;

                    case 'bulk':
                        bannerText = 'üì¶ Bulk pricing available - better prices for multiple downloads!';
                        bannerClass = 'bulk-mode';
                        console.log('üì¶ Set BULK mode banner');
                        break;

                    default:
                        bannerText = `üì∑ Photo downloads available (${this.policy.mode} mode)`;
                        bannerClass = '';
                        console.warn(`‚ö†Ô∏è Unknown pricing mode: ${this.policy.mode}`);
                }

                pricingInfo.textContent = bannerText;
                banner.classList.add(bannerClass);

                console.log(`‚úÖ Pricing banner updated: "${bannerText}" with class "${bannerClass}"`);
            }

            displayPhotos() {
                console.log('üé® Starting to display photos...');
                const grid = document.getElementById('galleryGrid');
                if (!grid) {
                    console.error('‚ùå Gallery grid element not found!');
                    return;
                }

                console.log(`üé® Clearing grid and rendering ${this.photos.length} photos`);
                grid.innerHTML = '';

                this.photos.forEach((photo, index) => {
                    console.log(`üé® Creating photo card ${index + 1}/${this.photos.length}:`, photo.filename);
                    try {
                        const photoCard = this.renderPhotoCard(photo, index);
                        grid.appendChild(photoCard);
                        console.log(`‚úÖ Photo card ${index + 1} added to grid`);
                    } catch (error) {
                        console.error(`‚ùå Error creating photo card ${index + 1}:`, error);
                    }
                });

                console.log(`üé® Gallery grid now has ${grid.children.length} photo cards`);

                // Apply screenshot protection to all displayed photos
                this.applyProtectionToPhotos();
                console.log('üé® Photo display complete');
            }

            applyProtectionToPhotos() {
                if (!this.protection) return;

                // Apply protection to all images based on entitlement status
                document.querySelectorAll('.gallery-photo').forEach(img => {
                    const photoId = img.dataset.photoId;
                    const isEntitled = img.dataset.entitled === 'true';

                    // Only protect unpurchased photos
                    if (!isEntitled) {
                        this.protection.protectImage(img, false);
                    } else {
                        // Mark as purchased for lighter protection
                        this.protection.purchasedPhotos.add(photoId);
                    }
                });
            }

            renderPhotoCard(photo, index) {
                // STANDARDIZED: Use filename as primary photo identifier
                // Fallback to index if filename is missing
                const photoIdToCheck = photo.filename || photo.id || String(index);
                const isEntitled = this.entitlements.some(e => 
                    e.photoId === photoIdToCheck ||     // PRIMARY: filename match
                    e.photoUrl === photo.url            // FALLBACK: URL-based match (backwards compatibility)
                );
                
                const price = this.calculatePrice(index, this.policy, this.entitlements.filter(e => e.photoId === photoIdToCheck).length);
                const isInCart = this.cart.some(item => item.photoId === photoIdToCheck);

                console.log(`üñºÔ∏è Rendering photo card ${index}: ${photoIdToCheck} (price: $${price === null ? 'N/A' : price.toFixed(2)}, hasEntitlement: ${isEntitled}, mode: ${this.policy?.mode})`);

                let priceBadge = '';
                // Show price badge only if not free, not entitled, and has a valid price
                if (this.policy && this.policy.mode !== 'free' && !isEntitled && price !== null && price !== undefined && price !== 0) {
                    priceBadge = `<div class="price-badge paid">$${price.toFixed(2)}</div>`;
                } else if (this.policy && this.policy.mode !== 'free' && !isEntitled && price === 0) {
                    // Show FREE badge if freemium and within free tier
                    priceBadge = `<div class="price-badge free">FREE</div>`;
                }

                let downloadButtonClass = 'download-btn';
                let downloadButtonText = 'üì• Download';
                let addToCartButtonClass = 'add-to-cart-btn';
                let addToCartButtonText = 'üõí Add to Cart';
                let showAddToCartButton = true;

                // Determine button states based on pricing model and entitlements
                if (isEntitled) {
                    // User already has entitlement - immediate download
                    downloadButtonClass += ' immediate';
                    downloadButtonText = 'üì• Download Now';
                    showAddToCartButton = false; // Hide cart button if already entitled

                    if (this.policy?.mode === 'free') {
                        downloadButtonClass += ' free';
                    } else {
                        downloadButtonClass += ' paid';
                    }
                } else {
                    // No entitlement yet - determine based on pricing model
                    switch (this.policy?.mode) {
                        case 'free':
                            downloadButtonClass += ' immediate free';
                            downloadButtonText = 'üì• Free Download';
                            showAddToCartButton = false; // No cart needed for free mode
                            break;

                        case 'freemium':
                            if (price === 0) {
                                // Within free limit
                                downloadButtonClass += ' immediate free';
                                downloadButtonText = 'üì• Free Download';
                                showAddToCartButton = false; // Free download, no cart needed
                            } else {
                                // Beyond free limit, requires payment
                                downloadButtonText = 'üõí Add to Cart';
                                addToCartButtonText = isInCart ? '‚úì In Cart' : 'üõí Add to Cart';
                                showAddToCartButton = true;
                            }
                            break;

                        case 'per_photo':
                        case 'fixed':
                        case 'paid':
                            // Always requires payment
                            downloadButtonText = 'üõí Add to Cart';
                            addToCartButtonText = isInCart ? '‚úì In Cart' : 'üõí Add to Cart';
                            showAddToCartButton = true;
                            break;

                        case 'bulk':
                            downloadButtonText = 'üõí Add to Cart';
                            addToCartButtonText = isInCart ? '‚úì In Cart' : 'üõí Add to Cart';
                            showAddToCartButton = true;
                            break;

                        default:
                            downloadButtonText = 'üì• Download'; // Fallback
                            showAddToCartButton = false;
                    }
                }

                if (isInCart) {
                    addToCartButtonClass += ' in-cart';
                    addToCartButtonText = '‚úì In Cart';
                }

                const cardClass = isInCart ? 'photo-card in-cart' : 'photo-card';

                // Build the action buttons HTML
                let actionButtonsHTML = '';

                if (showAddToCartButton) {
                    actionButtonsHTML += `
                        <button class="${addToCartButtonClass}" 
                                onclick="galleryCart.addToCart('${photoIdToCheck}', '${photo.url}', '${photo.filename}', ${price})"
                                data-photo-id="${photoIdToCheck}"
                                data-price="${price !== null && price !== undefined ? price.toFixed(2) : 'N/A'}">
                            ${addToCartButtonText}
                        </button>
                    `;
                }

                actionButtonsHTML += `
                    <button class="${downloadButtonClass}" 
                            onclick="galleryCart.downloadPhoto('${photoIdToCheck}', '${photo.url}', '${photo.filename}')"
                            data-photo-id="${photoIdToCheck}">
                        ${downloadButtonText}
                    </button>
                `;

                return `
                    <div class="${cardClass}" data-photo-id="${photoIdToCheck}">
                        <div class="photo-wrapper">
                            <img src="${photo.url}" alt="Gallery photo" loading="lazy" 
                                 data-photo-id="${photoIdToCheck}" 
                                 data-entitled="${isEntitled}"
                                 onerror="console.error('‚ùå Failed to load image:', this.src); this.style.display='none'; this.nextElementSibling.style.display='block';"
                                 onload="console.log('‚úÖ Image loaded:', this.src);">
                            <div style="display:none; padding: 40px; text-align: center; color: #999;">
                                Image unavailable
                            </div>
                            ${priceBadge}
                        </div>
                        <div class="photo-info">
                            <h3 class="photo-filename">${photo.filename || `Photo ${index + 1}`}</h3>
                            <div class="photo-actions">
                                ${actionButtonsHTML}
                            </div>
                        </div>
                    </div>
                `;
            }

            calculatePrice(photoIndex, policy, existingDownloads = 0) {
                if (!policy) {
                    console.warn('‚ö†Ô∏è No policy provided to calculatePrice');
                    return null; // Return null if no policy is available
                }

                console.log(`üí∞ Calculating price for photo ${photoIndex} (mode: ${policy.mode}, existing: ${existingDownloads}, cart size: ${this.cart.length})`);

                switch (policy.mode) {
                    case 'free':
                        console.log('üÜì FREE mode: $0.00');
                        return 0;

                    case 'freemium':
                        const freeCount = parseInt(policy.freeCount) || 0;
                        const priceAfterFree = parseFloat(policy.pricePerPhoto) || 5.00;
                        
                        // Check if this photo is already entitled (downloaded)
                        const photoIdToCheck = this.photos[photoIndex]?.filename || this.photos[photoIndex]?.id || String(photoIndex);
                        const isPhotoAlreadyEntitled = this.entitlements.some(e => e.photoId === photoIdToCheck);

                        if (isPhotoAlreadyEntitled) {
                            console.log('üéÅ FREEMIUM - Photo already entitled, price is effectively $0 for calculation purposes.');
                            return 0; // Already purchased, so effectively free for cart calculation
                        }

                        // Calculate total items in cart + this one
                        const currentCartSize = this.cart.length + 1;
                        
                        if (currentCartSize <= freeCount) {
                            console.log(`üéÅ FREEMIUM free slot: $0.00 (${currentCartSize}/${freeCount} in cart)`);
                            return 0; // Still within free limit for this item
                        } else {
                            console.log(`üíµ FREEMIUM paid slot: $${priceAfterFree} (${currentCartSize}/${freeCount} in cart)`);
                            return priceAfterFree; // Beyond free limit, charge
                        }

                    case 'per_photo':
                    case 'fixed':
                    case 'paid':
                        const paidPrice = parseFloat(policy.pricePerPhoto) || 5.00;
                        console.log(`üí∞ PAID mode: $${paidPrice}`);
                        return paidPrice;

                    case 'bulk':
                        // For bulk pricing, use the per-photo price as base
                        // Actual bulk discounts would be applied at checkout
                        const bulkPrice = parseFloat(policy.pricePerPhoto) || 5.00;
                        console.log(`üì¶ BULK mode: $${bulkPrice} (base price)`);
                        return bulkPrice;

                    default:
                        console.warn(`‚ö†Ô∏è Unknown pricing mode: ${policy.mode}`);
                        return null; // Return null for unknown modes
                }
            }

            toggleCartItem(photoId, photoUrl, filename, index) {
                const inCart = this.cart.some(item => item.photoId === photoId);

                if (inCart) {
                    this.removeFromCart(photoId);
                } else {
                    const price = this.calculatePrice(index, this.policy);
                    if (price === null) { // Handle cases where price calculation failed
                        this.showError('Could not determine price for this photo.');
                        return;
                    }
                    this.addToCart(photoId, photoUrl, filename, price);
                }
            }

            async addToCart(photoId, photoUrl, filename, price) {
                // Check if already in cart
                if (this.cart.some(item => item.photoId === photoId)) {
                    console.log(`üõí Item ${photoId} already in cart. Skipping add.`);
                    return;
                }

                try {
                    // Show loading state on the button
                    this.updateButtonState(photoId, 'Checking quota...');

                    // Call server API to validate quota and reserve slot
                    const response = await fetch(`${this.getApiBaseUrl()}/api/downloads/cart/add-item`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            sessionId: this.sessionData.id,
                            clientKey: this.getClientKey(),
                            photoId: photoId,
                            photoUrl: photoUrl,
                            filename: filename
                        })
                    });

                    const data = await response.json();

                    if (response.ok && data.success) {
                        // Server validated quota - now add to local cart
                        this.cart.push({
                            photoId,
                            photoUrl,
                            filename: filename || photoId, // Ensure filename is set
                            price: price || 0, // Use calculated price or 0 if null/undefined
                            reservationId: data.reservationId // Track server reservation
                        });

                        this.saveCart();
                        this.updateCartUI();
                        this.updatePhotoCardUI(photoId, true);
                        this.showSuccess('Photo added to cart!');

                        // Update quota display with server response
                        if (data.quota) {
                            this.updateQuotaDisplay(data.quota);
                        }

                        // Recalculate all prices for freemium/bulk modes after adding to cart
                        if (this.policy?.mode === 'freemium' || this.policy?.mode === 'bulk') {
                            this.recalculatePrices();
                        }
                    } else {
                        // Handle quota exceeded or other errors
                        if (data.code === 'QUOTA_EXCEEDED') {
                            this.showQuotaExceededError(data.error, data.quota);
                        } else if (data.code === 'ALREADY_PURCHASED') {
                            this.showError('This photo has already been purchased.');
                        } else {
                            this.showError(data.error || 'Failed to add photo to cart');
                        }

                        // Update quota display even on failure to show current state
                        if (data.quota) {
                            this.updateQuotaDisplay(data.quota);
                        }
                    }

                } catch (error) {
                    console.error('Error adding photo to cart:', error);
                    this.showError('Network error. Please check your connection and try again.');
                } finally {
                    // Reset button state - make sure it reflects actual cart status
                    const price = this.calculatePrice(this.photos.findIndex(p => p.id === photoId || p.filename === photoId), this.policy);
                    const isInCart = this.cart.some(item => item.photoId === photoId);
                    this.updateButtonState(photoId, isInCart ? '‚úì Added - Remove' : 'üõí Add to Cart', isInCart);
                }
            }

            async removeFromCart(photoId) {
                // Find the cart item to get reservation ID
                const cartItem = this.cart.find(item => item.photoId === photoId);
                if (!cartItem) {
                    console.log(`üõí Item ${photoId} not found in local cart. Skipping removal.`);
                    return; // Item not in cart
                }

                try {
                    // Call server API to release quota reservation
                    const response = await fetch(`${this.getApiBaseUrl()}/api/downloads/cart/remove-item`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            sessionId: this.sessionData.id,
                            clientKey: this.getClientKey(),
                            photoId: photoId
                        })
                    });

                    const data = await response.json();

                    if (response.ok && (data.success || response.status === 404)) { // Allow removal if server confirms or not found
                        // Remove from local cart
                        this.cart = this.cart.filter(item => item.photoId !== photoId);
                        this.saveCart();
                        this.updateCartUI();
                        this.updatePhotoCardUI(photoId, false);

                        // Update quota display with server response
                        if (data.quota) {
                            this.updateQuotaDisplay(data.quota);
                        }

                        // Recalculate all prices for freemium/bulk modes
                        if (this.policy?.mode === 'freemium' || this.policy?.mode === 'bulk') {
                            this.recalculatePrices();
                        }
                        this.showSuccess('Photo removed from cart.');
                    } else {
                        console.error('Failed to release server reservation:', data.error);
                        this.showNotification('Photo removed locally. Server sync will retry later.', 'warning');
                        // Still remove from local cart to avoid inconsistency
                        this.cart = this.cart.filter(item => item.photoId !== photoId);
                        this.saveCart();
                        this.updateCartUI();
                        this.updatePhotoCardUI(photoId, false);

                        if (this.policy?.mode === 'freemium' || this.policy?.mode === 'bulk') {
                            this.recalculatePrices();
                        }
                    }

                } catch (error) {
                    console.error('Error removing photo from cart:', error);
                    this.showNotification('Photo removed locally. Network error - server sync will retry later.', 'warning');
                    // Remove from local cart even if server call fails to avoid inconsistency
                    this.cart = this.cart.filter(item => item.photoId !== photoId);
                    this.saveCart();
                    this.updateCartUI();
                    this.updatePhotoCardUI(photoId, false);

                    if (this.policy?.mode === 'freemium' || this.policy?.mode === 'bulk') {
                        this.recalculatePrices();
                    }
                }
            }

            recalculatePrices() {
                // Recalculate prices for all items in cart based on current policy
                // For freemium mode, use position-based pricing to avoid circular dependency

                if (this.policy?.mode === 'freemium') {
                    const freeCount = parseInt(this.policy.freeCount) || 0;

                    // Count completed free downloads (entitlements that are active and not from an order)
                    const freeEntitlements = this.entitlements.filter(e => 
                        (!e.orderId || e.orderId === null) && e.isActive === true
                    );
                    const totalFreeDownloadsUsed = freeEntitlements.length;

                    // Recalculate each cart item based on its POSITION in the cart
                    this.cart.forEach((item, cartPosition) => {
                        // Find the photo index to get its entitlement status and original price
                        const photoIndex = this.photos.findIndex(p => p.filename === item.photoId || p.id === item.photoId);
                        if (photoIndex === -1) return; // Skip if photo no longer exists

                        // Check if this specific photo is already entitled
                        const isPhotoAlreadyEntitled = this.entitlements.some(e => {
                            return e.photoId === item.photoId; // Use photoId from cart item
                        });

                        if (isPhotoAlreadyEntitled) {
                            item.price = 0; // Already entitled, keep price as 0
                        } else {
                            // Position-based pricing: if cart position < remaining free slots, it's free
                            const remainingFreeSlots = Math.max(0, freeCount - totalFreeDownloadsUsed);
                            const canBeFree = cartPosition < remainingFreeSlots;
                            item.price = canBeFree ? 0 : parseFloat(this.policy.pricePerPhoto || 0);
                        }
                    });
                } else {
                    // For other modes (bulk, fixed, free, paid), use standard calculation
                    this.cart.forEach((item, index) => {
                        const photoIndex = this.photos.findIndex(p => p.filename === item.photoId || p.id === item.photoId);
                        if (photoIndex !== -1) {
                            item.price = this.calculatePrice(photoIndex, this.policy);
                        } else {
                            item.price = null; // Price is unknown if photo not found
                        }
                    });
                }

                this.saveCart();
                this.updateCartUI();
                this.displayPhotos(); // Refresh price badges and buttons
            }

            updatePhotoCardUI(photoId, inCart) {
                const cards = document.querySelectorAll('.photo-card');
                cards.forEach((card) => {
                    const photoIndex = card.dataset.photoId;
                    // STANDARDIZED: Use filename or ID from card's data-photo-id
                    if (photoIndex === photoId) {
                        card.classList.toggle('in-cart', inCart);

                        // Update button text
                        const btn = card.querySelector('.add-to-cart-btn');
                        if (btn) {
                            btn.textContent = inCart ? '‚úì In Cart' : 'üõí Add to Cart';
                            btn.classList.toggle('in-cart', inCart);
                        }
                    }
                });
            }

            updateCartUI() {
                const cartCount = document.getElementById('cartCount');
                const cartItemsContainer = document.getElementById('cartItems');
                const cartTotal = document.getElementById('cartTotal');
                const checkoutBtn = document.getElementById('checkoutBtn');

                // Update count
                cartCount.textContent = this.cart.length;

                // Update items display
                if (this.cart.length === 0) {
                    cartItemsContainer.innerHTML = `
                        <div class="cart-empty">
                            <div class="cart-empty-icon">üõí</div>
                            <h3>Your cart is empty</h3>
                            <p>Add photos to start your collection</p>
                        </div>
                    `;
                    checkoutBtn.disabled = true;
                } else {
                    cartItemsContainer.innerHTML = this.cart.map((item, index) => {
                        // Find photo details for image URL
                        const photo = this.photos.find(p => p.filename === item.photoId || p.id === item.photoId);
                        const imageUrl = photo?.url || item.photoUrl || '/static/img/placeholder.png'; // Fallback image

                        return `
                            <div class="cart-item" data-photo-id="${item.photoId}">
                                <div class="cart-item-image">
                                    <img src="${imageUrl}" alt="${item.filename}">
                                </div>
                                <div class="cart-item-details">
                                    <div class="cart-item-name">${item.filename}</div>
                                    <div class="cart-item-price">
                                        ${item.price === 0 ? 'FREE' : `$${item.price.toFixed(2)}`}
                                    </div>
                                </div>
                                <button class="cart-item-remove" onclick="galleryCart.removeFromCart('${item.photoId}')">
                                    ‚úï
                                </button>
                            </div>
                        `;
                    }).join('');
                    checkoutBtn.disabled = false;
                }

                // Update total
                const total = this.calculateTotal();
                cartTotal.textContent = total === 0 ? 'FREE' : `$${total.toFixed(2)}`;
            }

            calculateTotal() {
                return this.cart.reduce((total, item) => total + (item.price || 0), 0);
            }

            selectAllPhotos() {
                // Add all photos to cart that aren't already entitled or in cart
                this.photos.forEach((photo, index) => {
                    const photoId = photo.filename || photo.id || String(index);
                    const isEntitled = this.entitlements.some(e => e.photoId === photoId);
                    const inCart = this.cart.some(item => item.photoId === photoId);

                    if (!isEntitled && !inCart) {
                        const price = this.calculatePrice(index, this.policy);
                        if (price !== null) { // Only add if price is determined
                            this.addToCart(photoId, photo.url, photo.filename, price);
                        }
                    }
                });

                this.showSuccess('All available photos added to cart!');
            }

            async clearCart(silent = false) {
                if (silent || confirm('Are you sure you want to clear your cart?')) {
                    try {
                        // Call server API to clear all reservations
                        await fetch(`${this.getApiBaseUrl()}/api/downloads/cart/clear`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                sessionId: this.sessionData.id,
                                clientKey: this.getClientKey()
                            })
                        });
                    } catch (error) {
                        console.error('Error clearing server cart reservations:', error);
                        if (!silent) {
                            this.showNotification('Cart cleared locally. Server sync will be updated.', 'warning');
                        }
                        // Continue with local clear even if server call fails
                    }

                    this.cart = [];
                    this.saveCart();
                    this.updateCartUI();
                    this.photos.forEach(photo => { // Reset all photo cards
                        this.updatePhotoCardUI(photo.filename || photo.id, false);
                    });
                    this.closeCart();

                    // Refresh quota display
                    await this.loadQuotaStatus();
                }
            }

            async proceedToCheckout() {
                const total = this.calculateTotal();

                // If total is 0 (all free), process without payment
                if (total === 0) {
                    // Ensure cart is not empty before proceeding
                    if (this.cart.length === 0) {
                        this.showError('Your cart is empty.');
                        return;
                    }
                    await this.processFreeDownloads();
                    return;
                }

                // Check if we have client email
                if (!this.clientEmail) {
                    this.showEmailModal();
                    return;
                }

                // Validate cart before proceeding to payment
                const validation = await this.validateCartBeforeCheckout();

                if (!validation.isValid) {
                    // Handle validation failure
                    await this.handleCartValidationFailure(validation);
                    return;
                }

                // Create checkout session
                await this.createCheckoutSession();
            }

            async processFreeDownloads() {
                try {
                    // For free downloads, create entitlements directly
                    const items = this.cart.map(item => ({
                        photoId: item.photoId,
                        photoUrl: item.photoUrl,
                        filename: item.filename
                    }));

                    const response = await fetch(`${this.getApiBaseUrl()}/api/downloads/entitlements`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            sessionId: this.sessionData.id,
                            clientKey: this.getClientKey(),
                            items: items,
                            type: 'free'
                        })
                    });

                    const data = await response.json();

                    if (response.ok && data.success) {
                        this.clearCart(true); // Silent clear after successful free downloads
                        this.closeCart();
                        await this.loadEntitlements();
                        this.displayPhotos();
                        this.showSuccess('Free downloads are ready! Click download on each photo.');
                        await this.loadQuotaStatus(); // Update quota after free downloads
                    } else {
                        throw new Error(data.error || 'Failed to process free downloads');
                    }

                } catch (error) {
                    console.error('Error processing free downloads:', error);
                    alert('Failed to process downloads. Please try again.');
                }
            }

            async createCheckoutSession() {
                try {
                    // Show loading state
                    const checkoutBtn = document.getElementById('checkoutBtn');
                    const originalText = checkoutBtn.textContent;
                    checkoutBtn.disabled = true;
                    checkoutBtn.textContent = 'Processing...';

                    // Prepare items for checkout
                    const items = this.cart.map(item => item.photoId);

                    const response = await fetch(`${this.getApiBaseUrl()}/api/downloads/checkout`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            sessionId: this.sessionData.id,
                            clientKey: this.clientEmail, // Use email as clientKey for checkout
                            clientName: this.clientName,
                            items: items
                        })
                    });

                    const data = await response.json();

                    if (response.ok && data.success && data.checkoutUrl) {
                        // Redirect to Stripe Checkout
                        window.location.href = data.checkoutUrl;
                    } else {
                        throw new Error(data.error || 'Failed to create checkout session');
                    }

                } catch (error) {
                    console.error('Error creating checkout:', error);
                    alert(`Checkout failed: ${error.message}`);

                    // Reset button
                    const checkoutBtn = document.getElementById('checkoutBtn');
                    checkoutBtn.disabled = false;
                    checkoutBtn.textContent = 'Proceed to Checkout';
                }
            }

            async handleCheckoutReturn() {
                if (this.checkoutStatus === 'success') {
                    // Clear cart after successful purchase (silent - no confirmation)
                    this.clearCart(true);

                    // Load entitlements to show purchased items
                    if (this.clientEmail) { // Ensure client email is available
                        await this.loadEntitlements();
                    }

                    // Refresh gallery to show download buttons
                    this.displayPhotos();

                    // Show success message
                    this.showSuccess('Payment successful! Your photos are ready to download.');

                    // Remove URL parameters
                    window.history.replaceState({}, document.title, window.location.pathname);

                } else if (this.checkoutStatus === 'cancel') {
                    // Show message that checkout was cancelled
                    this.showSuccess('Checkout cancelled. Your cart has been saved.');

                    // Remove URL parameters
                    window.history.replaceState({}, document.title, window.location.pathname);
                }
            }

            async loadEntitlements() {
                try {
                    if (!this.sessionData?.id) {
                        console.warn('‚ö†Ô∏è Cannot load entitlements: missing session data');
                        return;
                    }

                    // Use same clientKey logic as processFreeDownloads to avoid mismatch
                    const clientKey = this.getClientKey();

                    console.log(`üîç Loading entitlements for clientKey: ${clientKey} (session: ${this.sessionData.id})`);

                    // Fetch entitlements using the unified API endpoint
                    const response = await fetch(`${this.getApiBaseUrl()}/api/downloads/unified/entitlements?sessionId=${encodeURIComponent(this.sessionData.id)}&clientKey=${encodeURIComponent(clientKey)}`, {
                        method: 'GET'
                    });

                    const data = await response.json();

                    if (response.ok && data.success) {
                        this.entitlements = data.entitlements || [];
                        console.log(`‚úÖ Loaded ${this.entitlements.length} entitlements for ${clientKey}`);

                        // Update pricing banner for freemium mode
                        await this.updatePricingBanner();
                    } else {
                        console.error('Failed to load entitlements:', data.error);
                        this.entitlements = [];
                    }

                } catch (error) {
                    console.error('‚ùå Error loading entitlements:', error);
                    this.entitlements = [];
                }
            }

            async downloadPhoto(photoId, photoUrl, filename, fromCart = false) {
                try {
                    console.log(`‚¨áÔ∏è [SIMPLE] Starting download for photo: ${photoId}`);

                    if (!this.galleryToken || !this.sessionData) {
                        this.showError('Gallery access not properly initialized');
                        return;
                    }

                    // Show download progress
                    this.showProgress('Preparing download...');

                    const downloadPayload = {
                        galleryAccessToken: this.galleryToken,
                        sessionId: this.sessionData.id,
                        photoId: photoId,
                        photoUrl: photoUrl,
                        filename: filename
                    };

                    console.log(`üì° [SIMPLE] Sending download request:`, downloadPayload);

                    const response = await fetch(`${this.getApiBaseUrl()}/api/downloads/simple/download`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(downloadPayload)
                    });

                    const result = await response.json();
                    this.hideProgress();

                    console.log(`üìã [SIMPLE] Download response:`, result);

                    if (result.success && result.downloadUrl) {
                        console.log(`‚úÖ [SIMPLE] Download authorized for photo: ${photoId}`);

                        // Trigger actual download
                        const link = document.createElement('a');
                        link.href = result.downloadUrl;
                        link.download = result.filename || filename;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);

                        // Show success message
                        const downloadType = result.downloadType === 'unlimited' ? 'Unlimited' : 'Free';
                        this.showSuccess(`Downloaded: ${filename} (${downloadType})`);

                        // Update credit status display
                        if (this.creditStatus) {
                            if (result.downloadType !== 'unlimited') {
                                this.creditStatus.freeDownloadsRemaining = result.remainingDownloads;
                            }
                            this.updateCreditDisplay();
                        }

                        // Refresh credit status from server
                        await this.fetchCreditStatus();

                    } else if (response.status === 402 && result.code === 'PAYMENT_REQUIRED') {
                        console.log(`üí≥ [SIMPLE] Payment required - showing unlock modal`);
                        
                        // Show unlock modal
                        this.showUnlockModal(result.unlimitedAccessPrice);

                    } else {
                        console.warn(`‚ö†Ô∏è [SIMPLE] Download failed for photo: ${photoId}`, result);
                        this.showError(result.error || 'Download failed');
                    }

                } catch (error) {
                    this.hideProgress();
                    console.error('‚ùå [SIMPLE] Error downloading photo:', error);
                    this.showError('Download failed. Please try again.');
                }
            }

            // UI Helper Methods
            openCart() {
                document.getElementById('cartDrawer').classList.add('open');
                document.getElementById('cartOverlay').classList.add('show');
                document.body.style.overflow = 'hidden';
            }

            closeCart() {
                document.getElementById('cartDrawer').classList.remove('open');
                document.getElementById('cartOverlay').classList.remove('show');
                document.body.style.overflow = '';
            }

            showEmailModal() {
                document.getElementById('emailModal').classList.add('show');

                // Pre-fill if we have saved info
                if (this.clientEmail) {
                    document.getElementById('clientEmail').value = this.clientEmail;
                }
                if (this.clientName) {
                    document.getElementById('clientName').value = this.clientName;
                }
            }

            closeEmailModal() {
                document.getElementById('emailModal').classList.remove('show');
            }

            handleEmailSubmit(e) {
                e.preventDefault();

                this.clientEmail = document.getElementById('clientEmail').value;
                this.clientName = document.getElementById('clientName').value;

                // Save client info
                this.saveClientInfo();

                // Close modal and proceed with checkout
                this.closeEmailModal();
                this.createCheckoutSession();
            }

            showSuccess(message) {
                const successMessage = document.getElementById('successMessage');
                const successText = document.getElementById('successText');

                successText.textContent = message;
                successMessage.classList.add('show');

                setTimeout(() => {
                    successMessage.classList.remove('show');
                }, 3000);
            }

            showError(message, errorType = 'general') {
                console.error(`üö® Error [${errorType}]:`, message);

                // Show error in the error container
                document.getElementById('loadingContainer').style.display = 'none';
                document.getElementById('errorContainer').style.display = 'block';
                document.getElementById('errorMessage').textContent = message;

                // Also show as a temporary toast notification
                this.showToast(message, 'error', errorType);
            }

            /**
             * Show user notification for cart sync issues and warnings
             * This is a convenience wrapper around showToast for cart-related notifications
             */
            showNotification(message, type = 'info') {
                console.log(`üì¢ User Notification [${type}]:`, message);
                this.showToast(message, type, 'cart-sync');
            }

            showUnlockModal(price = null) {
                const modal = document.getElementById('unlockModal');
                const priceElement = document.getElementById('unlockPrice');
                
                if (price !== null && price !== undefined) {
                    priceElement.textContent = `$${price.toFixed(2)}`;
                } else if (this.creditStatus && this.creditStatus.unlimitedAccessPrice) {
                    priceElement.textContent = `$${this.creditStatus.unlimitedAccessPrice.toFixed(2)}`;
                } else {
                    priceElement.textContent = '$0.00';
                }

                modal.classList.add('show');
                console.log('üì∏ [SIMPLE] Showing unlock all photos modal');
            }

            hideUnlockModal() {
                const modal = document.getElementById('unlockModal');
                modal.classList.remove('show');
            }

            async unlockAllPhotos() {
                try {
                    console.log('üîì [SIMPLE] Initiating unlock all photos purchase...');
                    this.hideUnlockModal();
                    this.showProgress('Processing payment...');

                    this.showToast('Unlock All Photos feature coming soon! This will integrate with Stripe checkout.', 'info');
                    this.hideProgress();

                } catch (error) {
                    this.hideProgress();
                    console.error('‚ùå [SIMPLE] Error unlocking photos:', error);
                    this.showError('Failed to process payment. Please try again.');
                }
            }

            /**
             * Enhanced toast notification system
             */
            showToast(message, type = 'info', category = '') {
                const toastId = 'toast-' + Date.now();
                const iconMap = {
                    'success': '‚úÖ',
                    'error': '‚ùå',
                    'warning': '‚ö†Ô∏è',
                    'info': '‚ÑπÔ∏è',
                    'rate-limit': 'üïê',
                    'network-error': 'üåê',
                    'quota-exceeded': 'üìä'
                };

                const icon = iconMap[type] || iconMap[category] || iconMap['info'];

                const toast = document.createElement('div');
                toast.id = toastId;
                toast.className = `toast toast-${type} ${category ? `toast-${category}` : ''}`;
                toast.innerHTML = `
                    <span class="toast-icon">${icon}</span>
                    <span class="toast-message">${message}</span>
                    <button class="toast-close" onclick="this.parentElement.remove()">√ó</button>
                `;

                // Add to toast container or create one
                let toastContainer = document.getElementById('toastContainer');
                if (!toastContainer) {
                    toastContainer = document.createElement('div');
                    toastContainer.id = 'toastContainer';
                    toastContainer.className = 'toast-container';
                    document.body.appendChild(toastContainer);
                }

                toastContainer.appendChild(toast);

                // Auto-remove after delay based on message type
                const delays = {
                    'success': 3000,
                    'info': 4000,
                    'warning': 6000,
                    'error': 8000,
                    'rate-limit': 10000
                };

                const delay = delays[type] || delays[category] || 5000;

                setTimeout(() => {
                    const toastEl = document.getElementById(toastId);
                    if (toastEl) {
                        toastEl.classList.add('toast-fade-out');
                        setTimeout(() => toastEl.remove(), 300);
                    }
                }, delay);
            }

            // ========================================
            // QUOTA MANAGEMENT METHODS
            // ========================================

            updateQuotaDisplay(quotaInfo) {
                const quotaContainer = document.getElementById('quotaInfo');
                if (!quotaInfo) {
                    quotaContainer.style.display = 'none';
                    return;
                }

                // Show/hide quota info based on quota limits and pricing mode
                if (quotaInfo.unlimited || (!quotaInfo.limit && quotaInfo.limit !== 0)) {
                    quotaContainer.style.display = 'none';
                    return;
                }

                quotaContainer.style.display = 'block';

                const quotaText = document.getElementById('quotaText');
                const quotaProgress = document.getElementById('quotaProgress');
                const quotaBar = document.getElementById('quotaBar');

                // Enhanced quota info with unified API support
                const remaining = quotaInfo.remaining || quotaInfo.freeRemaining || 0;
                const total = quotaInfo.limit || quotaInfo.freeTotal || 0;
                const used = quotaInfo.used || 0;
                const reserved = quotaInfo.reserved || quotaInfo.cartReserved || 0;

                // Handle freemium mode differently
                let quotaMessage = '';
                if (this.policy?.mode === 'freemium') {
                    const freeRemaining = quotaInfo.freeRemaining || 0;
                    const freeTotal = quotaInfo.freeTotal || this.policy.freeCount || 0;
                    const reservedText = reserved > 0 ? ` (${reserved} in cart)` : '';

                    if (freeRemaining > 0) {
                        quotaMessage = `üÜì ${freeRemaining} of ${freeTotal} FREE downloads remaining${reservedText}`;
                    } else {
                        quotaMessage = `üí≥ Free quota used - paid downloads only${reservedText}`;
                    }
                } else {
                    // Standard quota display for other modes
                    const reservedText = reserved > 0 ? ` (${reserved} in cart)` : '';
                    quotaMessage = `${remaining} of ${total} downloads remaining${reservedText}`;
                }

                // Add rate limiting info if applicable
                if (quotaInfo.rateLimited) {
                    const retryAfter = quotaInfo.retryAfter || 60;
                    quotaMessage += ` ‚ö†Ô∏è Rate limited (${retryAfter}s)`;
                }

                quotaText.textContent = quotaMessage;

                // Update progress bar with enhanced visual feedback
                if (total > 0) {
                    const percentage = Math.max(0, (remaining / total) * 100);
                    quotaBar.style.width = `${percentage}%`;

                    // Enhanced color coding based on remaining quota and mode
                    quotaBar.className = 'quota-bar';
                    if (percentage <= 0) {
                        quotaBar.classList.add('quota-exhausted');
                    } else if (percentage <= 10) {
                        quotaBar.classList.add('quota-critical');
                    } else if (percentage <= 25) {
                        quotaBar.classList.add('quota-warning');
                    } else if (percentage <= 50) {
                        quotaBar.classList.add('quota-medium');
                    } else {
                        quotaBar.classList.add('quota-good');
                    }

                    // Add special styling for freemium mode
                    if (this.policy?.mode === 'freemium') {
                        quotaBar.classList.add('quota-freemium');
                    }
                } else {
                    // Handle unlimited or no-limit scenarios
                    quotaBar.style.width = '100%';
                    quotaBar.className = 'quota-bar quota-unlimited';
                }

                // Store quota info for use in other methods
                this.currentQuota = quotaInfo;
            }

            showQuotaExceededError(message, quotaInfo) {
                // Create a more detailed error modal for quota exceeded
                const modal = document.createElement('div');
                modal.className = 'quota-modal-overlay';
                modal.innerHTML = `
                    <div class="quota-modal">
                        <div class="quota-modal-header">
                            <h3>‚ö†Ô∏è Download Limit Reached</h3>
                        </div>
                        <div class="quota-modal-body">
                            <p>${message}</p>
                            ${quotaInfo ? `
                                <div class="quota-details">
                                    <p><strong>Your Current Usage:</strong></p>
                                    <ul>
                                        <li>Used: ${quotaInfo.used || 0} downloads</li>
                                        <li>Limit: ${quotaInfo.limit || 0} downloads</li>
                                        <li>Remaining: ${quotaInfo.remaining || 0} downloads</li>
                                    </ul>
                                </div>
                            ` : ''}
                            <p>Remove items from your cart or complete your purchase to continue.</p>
                        </div>
                        <div class="quota-modal-actions">
                            <button class="quota-modal-btn primary" onclick="this.closest('.quota-modal-overlay').remove()">
                                OK
                            </button>
                        </div>
                    </div>
                `;

                document.body.appendChild(modal);

                // Auto-remove after 8 seconds
                setTimeout(() => {
                    if (modal.parentNode) {
                        modal.remove();
                    }
                }, 8000);
            }

            async loadQuotaStatus() {
                try {
                    if (!this.sessionData?.id || !this.galleryToken) {
                        console.warn('‚ö†Ô∏è Cannot load quota status: missing session data or gallery token');
                        return;
                    }

                    // Use unified API for quota status
                    const statusResult = await this.getUnifiedSessionStatus();

                    if (statusResult.success && statusResult.quota) {
                        this.updateQuotaDisplay(statusResult.quota);

                        // Also update policy if it has changed
                        if (statusResult.policy) {
                            this.policy = statusResult.policy;
                        }

                        // Update entitlements if provided
                        if (statusResult.entitlements) {
                            this.entitlements = statusResult.entitlements;
                        }
                    } else {
                        console.warn('‚ö†Ô∏è Failed to load quota status:', statusResult.error);
                    }
                } catch (error) {
                    console.error('‚ùå Error loading quota status:', error);
                }
            }

            async fetchCreditStatus() {
                try {
                    if (!this.sessionData?.id || !this.galleryToken) {
                        console.warn('‚ö†Ô∏è Cannot fetch credit status: missing session data or gallery token');
                        return;
                    }

                    console.log(`üìä [SIMPLE] Fetching credit status for session: ${this.sessionData.id}`);

                    const response = await fetch(
                        `${this.getApiBaseUrl()}/api/downloads/simple/status/${this.sessionData.id}?galleryAccessToken=${this.galleryToken}`,
                        {
                            method: 'GET',
                            headers: { 'Content-Type': 'application/json' }
                        }
                    );

                    const data = await response.json();

                    if (response.ok && data.success) {
                        console.log('‚úÖ [SIMPLE] Credit status loaded:', data);
                        
                        this.creditStatus = {
                            freeDownloadsRemaining: data.freeDownloadsRemaining || 0,
                            unlimitedAccess: data.unlimitedAccess || false,
                            unlimitedAccessPrice: data.unlimitedAccessPrice || null,
                            totalPhotos: data.totalPhotos || 0,
                            pricingModel: data.pricingModel || 'free'
                        };

                        this.updateCreditDisplay();
                    } else {
                        console.error('‚ùå [SIMPLE] Failed to fetch credit status:', data.error);
                        this.showError('Failed to load credit status');
                    }
                } catch (error) {
                    console.error('‚ùå [SIMPLE] Error fetching credit status:', error);
                    this.showError('Network error loading credit status');
                }
            }

            updateCreditDisplay() {
                const banner = document.getElementById('creditBanner');
                const creditText = document.getElementById('creditText');
                const unlockBtn = document.getElementById('unlockAllBtn');

                if (!banner || !creditText || !unlockBtn || !this.creditStatus) {
                    return;
                }

                banner.classList.remove('unlimited', 'low-credits', 'no-credits');
                banner.classList.add('show');

                if (this.creditStatus.unlimitedAccess) {
                    banner.classList.add('unlimited');
                    creditText.textContent = 'Unlimited downloads unlocked ‚úì';
                    unlockBtn.style.display = 'none';
                } else if (this.creditStatus.freeDownloadsRemaining > 0) {
                    const remaining = this.creditStatus.freeDownloadsRemaining;
                    if (remaining <= 2) {
                        banner.classList.add('low-credits');
                    }
                    creditText.textContent = `You have ${remaining} free download${remaining !== 1 ? 's' : ''} remaining`;
                    
                    if (this.creditStatus.unlimitedAccessPrice) {
                        unlockBtn.style.display = 'block';
                        unlockBtn.textContent = `Unlock All for $${this.creditStatus.unlimitedAccessPrice.toFixed(2)}`;
                    }
                } else {
                    banner.classList.add('no-credits');
                    creditText.textContent = 'No free downloads remaining';
                    
                    if (this.creditStatus.unlimitedAccessPrice) {
                        unlockBtn.style.display = 'block';
                        unlockBtn.textContent = `Unlock All Photos for $${this.creditStatus.unlimitedAccessPrice.toFixed(2)}`;
                    }
                }

                console.log('‚úÖ [SIMPLE] Credit display updated');
            }

            /**
             * Helper method to update quota display from unified API
             */
            async updateQuotaFromUnifiedAPI() {
                try {
                    const statusResult = await this.getUnifiedSessionStatus();
                    if (statusResult.success && statusResult.quota) {
                        this.updateQuotaDisplay(statusResult.quota);
                        await this.updatePricingBanner(); // Update banner as well, as policy might change
                    }
                } catch (error) {
                    console.error('‚ùå Error updating quota from unified API:', error);
                }
            }

            /**
             * Enhanced error handling with retry mechanisms
             */
            async makeUnifiedApiCall(apiCall, retries = 3, delay = 1000) {
                for (let attempt = 1; attempt <= retries; attempt++) {
                    try {
                        const result = await apiCall();
                        if (result.success) {
                            return result;
                        }

                        // Handle specific error codes
                        if (result.code === 'RATE_LIMIT_EXCEEDED' && attempt < retries) {
                            const retryAfter = result.retryAfter || delay;
                            console.log(`üîÑ Rate limited, retrying after ${retryAfter}ms (attempt ${attempt}/${retries})`);
                            await this.sleep(retryAfter);
                            continue;
                        }

                        return result; // Return the error result if not retryable

                    } catch (error) {
                        console.error(`‚ùå API call failed (attempt ${attempt}/${retries}):`, error);

                        // Network errors - retry with exponential backoff
                        if (attempt < retries && (error.name === 'NetworkError' || error.message.includes('fetch') || error.message.includes('network'))) {
                            const retryDelay = delay * Math.pow(2, attempt - 1);
                            console.log(`üîÑ Network error, retrying after ${retryDelay}ms`);
                            await this.sleep(retryDelay);
                            continue;
                        }

                        return {
                            success: false,
                            error: `Network error: ${error.message}`,
                            code: 'NETWORK_ERROR'
                        };
                    }
                }

                return {
                    success: false,
                    error: 'Maximum retries exceeded',
                    code: 'MAX_RETRIES_EXCEEDED'
                };
            }

            /**
             * Utility method for delays
             */
            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            /**
             * Enhanced download with progress tracking
             */
            async downloadWithProgress(photoId, photoUrl, filename, isPaid = false, paymentIntentId = null) {
                const progressIndicator = this.showProgressIndicator(`Processing ${filename}...`);

                try {
                    // Use retry mechanism for download processing
                    const result = await this.makeUnifiedApiCall(() => 
                        this.processUnifiedDownload(photoId, photoUrl, filename, isPaid, paymentIntentId)
                    );

                    const downloadToken = result?.downloadToken; // Use unified token directly
                    if (result && result.success && downloadToken) {
                        this.updateProgress(progressIndicator, 'Downloading file...', 80);

                        // Trigger download
                        const downloadUrl = `${this.getApiBaseUrl()}/api/downloads/${downloadToken}`;
                        const link = document.createElement('a');
                        link.href = downloadUrl;
                        link.download = filename;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);

                        this.updateProgress(progressIndicator, 'Download complete!', 100);
                        setTimeout(() => this.hideProgressIndicator(progressIndicator), 1000);

                        // Update quota display
                        await this.updateQuotaFromUnifiedAPI();

                        return { success: true };

                    } else {
                        this.hideProgressIndicator(progressIndicator);
                        console.error('‚ùå Download failed with result:', result);

                        if (result) {
                            this.handleDownloadError(result, photoId, photoUrl, filename);
                        } else {
                            this.showError('Download failed: No response received');
                        }
                        return result;
                    }
                } catch (error) {
                    this.hideProgressIndicator(progressIndicator);
                    console.error('‚ùå Download with progress failed:', error);
                    this.showError(`Download failed: ${error.message}`);
                    return { success: false, error: error.message };
                }
            }

            /**
             * Show progress indicator
             */
            showProgressIndicator(message) {
                const progressId = 'progress-' + Date.now();
                const progressHtml = `
                    <div id="${progressId}" class="progress-indicator">
                        <div class="progress-content">
                            <div class="progress-spinner"></div>
                            <div class="progress-message">${message}</div>
                            <div class="progress-bar">
                                <div class="progress-fill" style="width: 10%"></div>
                            </div>
                        </div>
                    </div>
                `;

                document.body.insertAdjacentHTML('beforeend', progressHtml);
                return progressId;
            }

            /**
             * Update progress indicator
             */
            updateProgress(progressId, message, percentage) {
                const indicator = document.getElementById(progressId);
                if (indicator) {
                    const messageEl = indicator.querySelector('.progress-message');
                    const fillEl = indicator.querySelector('.progress-fill');
                    if (messageEl) messageEl.textContent = message;
                    if (fillEl) fillEl.style.width = `${percentage}%`;
                }
            }

            /**
             * Hide progress indicator
             */
            hideProgressIndicator(progressId) {
                const indicator = document.getElementById(progressId);
                if (indicator) {
                    indicator.remove();
                }
            }

            /**
             * Enhanced error handling for downloads
             */
            handleDownloadError(result, photoId, photoUrl, filename) {
                const errorCode = result.code;
                const errorMessage = result.error || 'Download failed';

                switch (errorCode) {
                    case 'PAYMENT_REQUIRED':
                        if (result.paymentInfo) {
                            this.handlePaymentRequired(result.paymentInfo, photoId, photoUrl, filename);
                        } else {
                            this.showError('Payment required for this download. Please add to cart.');
                        }
                        break;

                    case 'RATE_LIMIT_EXCEEDED':
                        const retryAfter = result.retryAfter || 60;
                        this.showError(`Too many requests. Please wait ${retryAfter} seconds before trying again.`, 'rate-limit');
                        break;

                    case 'QUOTA_EXCEEDED':
                        this.handleQuotaExceeded(photoId, photoUrl, filename);
                        break;

                    case 'NETWORK_ERROR':
                        this.showError('Network connection error. Please check your connection and try again.', 'network-error');
                        break;

                    case 'GALLERY_EXPIRED':
                        this.showError('This gallery has expired and downloads are no longer available.', 'gallery-expired');
                        break;

                    case 'INVALID_SESSION':
                        this.showError('Your session has expired. Please refresh the page.', 'session-expired');
                        break;

                    default:
                        this.showError(`Download failed: ${errorMessage}`, 'general-error');
                }
            }

            /**
             * Handle quota exceeded scenarios
             */
            handleQuotaExceeded(photoId, photoUrl, filename) {
                if (this.policy?.mode === 'freemium') {
                    // Auto-add to cart in freemium mode
                    const paidPrice = this.policy?.pricePerPhoto ? parseFloat(this.policy.pricePerPhoto) : 5.00;
                    this.addToCart(photoId, photoUrl, filename, paidPrice);
                    this.showError(`Free quota exhausted! Added ${filename} to cart for $${paidPrice.toFixed(2)}`, 'quota-exceeded');
                    this.updatePricingBanner();
                    this.displayPhotos();
                } else {
                    this.showError('Download quota exceeded. Please upgrade or wait for quota reset.', 'quota-exceeded');
                }
            }

            /**
             * Handle payment required scenarios from unified API
             */
            handlePaymentRequired(paymentInfo, photoId, photoUrl, filename) {
                try {
                    console.log('üí≥ Payment required for download:', paymentInfo);

                    // Auto-add to cart for payment processing
                    const price = paymentInfo.amount || (this.policy?.pricePerPhoto ? parseFloat(this.policy.pricePerPhoto) : 5.00);
                    this.addToCart(photoId, photoUrl, filename, price);

                    // Show user-friendly message
                    this.showError(`This download requires payment ($${price.toFixed(2)}). Added to cart for checkout.`);

                    // Update UI to show cart
                    this.openCart();

                } catch (error) {
                    console.error('‚ùå Error handling payment required:', error);
                    this.showError('Payment required - please add photo to cart');
                }
            }

            // Storage Methods
            saveCart() {
                localStorage.setItem(`cart_${this.galleryToken}`, JSON.stringify(this.cart));
            }

            loadCart() {
                const saved = localStorage.getItem(`cart_${this.galleryToken}`);
                if (saved) {
                    try {
                        this.cart = JSON.parse(saved);
                        console.log(`üì¶ Loaded ${this.cart.length} items from saved cart`);
                    } catch (error) {
                        console.error('Error loading cart:', error);
                        this.cart = [];
                    }
                }
            }

            /**
             * Validate cart before checkout
             * Ensures backend cart state matches client UI state to prevent payment/entitlement mismatches
             */
            async validateCartBeforeCheckout() {
                try {
                    console.log('üîç Validating cart before checkout...');

                    // Fetch current cart status from backend
                    const backendStatus = await this.fetchCartStatus();

                    // Handle network errors - allow proceeding with warning
                    if (backendStatus.networkError || !backendStatus.backendAvailable) {
                        console.warn('‚ö†Ô∏è Network error during validation - allowing checkout with warning');
                        return {
                            isValid: true,
                            warning: true,
                            message: 'Unable to validate cart. Proceeding with current selections.',
                            reason: 'network_error'
                        };
                    }

                    // Handle backend errors
                    if (!backendStatus.success) {
                        return {
                            isValid: false,
                            message: 'Cart validation failed. Please try again.',
                            reason: 'backend_error',
                            error: backendStatus.error
                        };
                    }

                    // Get backend and local cart items
                    const backendItems = backendStatus.cart?.items || [];
                    const localItems = this.cart || [];

                    // Create maps for efficient comparison
                    const backendMap = new Map();
                    backendItems.forEach(item => {
                        backendMap.set(item.photoId, item);
                    });

                    const localMap = new Map();
                    localItems.forEach(item => {
                        localMap.set(item.photoId, item);
                    });

                    // Check for discrepancies
                    const discrepancies = {
                        missingFromBackend: [],
                        missingFromUI: [],
                        priceChanges: []
                    };

                    // Check items in UI but not on backend (reservation lost)
                    for (const [photoId, localItem] of localMap) {
                        if (!backendMap.has(photoId)) {
                            console.warn(`‚ö†Ô∏è Item in UI but not on backend: ${localItem.filename}`);
                            discrepancies.missingFromBackend.push(localItem);
                        }
                    }

                    // Check items on backend but not in UI (UI out of sync)
                    for (const [photoId, backendItem] of backendMap) {
                        if (!localMap.has(photoId)) {
                            console.warn(`‚ö†Ô∏è Item on backend but not in UI: ${backendItem.filename}`);
                            discrepancies.missingFromUI.push(backendItem);
                        }
                    }

                    // Check for price mismatches
                    for (const [photoId, localItem] of localMap) {
                        const backendItem = backendMap.get(photoId);
                        if (backendItem) {
                            const localPrice = parseFloat(localItem.price) || 0;
                            const backendPrice = parseFloat(backendItem.price) || 0;

                            if (Math.abs(localPrice - backendPrice) > 0.01) {
                                console.warn(`‚ö†Ô∏è Price mismatch for ${localItem.filename}: UI=$${localPrice}, Backend=$${backendPrice}`);
                                discrepancies.priceChanges.push({
                                    photoId,
                                    filename: localItem.filename,
                                    oldPrice: localPrice,
                                    newPrice: backendPrice
                                });
                            }
                        }
                    }

                    // Determine if cart is valid
                    const hasDiscrepancies = 
                        discrepancies.missingFromBackend.length > 0 ||
                        discrepancies.missingFromUI.length > 0 ||
                        discrepancies.priceChanges.length > 0;

                    if (hasDiscrepancies) {
                        console.warn('‚ùå Cart validation failed - discrepancies found:', discrepancies);

                        // Determine primary reason for failure
                        let reason = 'unknown';
                        let message = 'Cart has changed. Please review your cart.';

                        if (discrepancies.missingFromBackend.length > 0) {
                            reason = 'reservations_lost';
                            message = 'Some items are no longer available. Please review your cart.';
                        } else if (discrepancies.priceChanges.length > 0) {
                            reason = 'price_changed';
                            message = 'Prices have been updated. Please confirm before checkout.';
                        } else if (discrepancies.missingFromUI.length > 0) {
                            reason = 'ui_out_of_sync';
                            message = 'Cart has changed. Refreshing...';
                        }

                        return {
                            isValid: false,
                            message,
                            reason,
                            discrepancies,
                            backendStatus
                        };
                    }

                    console.log('‚úÖ Cart validation successful - all items match');
                    return {
                        isValid: true,
                        message: 'Cart validated successfully'
                    };

                } catch (error) {
                    console.error('‚ùå Error validating cart:', error);

                    // Allow proceeding with warning on unexpected errors
                    return {
                        isValid: true,
                        warning: true,
                        message: 'Unable to validate cart. Proceeding with current selections.',
                        reason: 'validation_error',
                        error: error.message
                    };
                }
            }

            /**
             * Handle cart validation failure
             * Shows user-friendly messages and offers to resync cart
             */
            async handleCartValidationFailure(validation) {
                const { reason, message, discrepancies } = validation;

                // Show loading state while handling
                const checkoutBtn = document.getElementById('checkoutBtn');
                const originalText = checkoutBtn?.textContent || 'Proceed to Checkout';
                if (checkoutBtn) {
                    checkoutBtn.disabled = true;
                    checkoutBtn.textContent = 'Validating...';
                }

                try {
                    switch (reason) {
                        case 'reservations_lost':
                            // Items in UI but not on backend - reservations expired or lost
                            if (confirm(`${message}\n\nWould you like to refresh your cart and try to re-reserve these items?`)) {
                                console.log('üîÑ User chose to reconcile cart after reservation loss');
                                await this.reconcileCart();
                                this.updateCartUI();
                                this.showSuccess('Cart refreshed. Please review and try checkout again.');
                            } else {
                                console.log('‚ùå User cancelled cart reconciliation');
                                this.showError('Please review your cart before checkout.');
                            }
                            break;

                        case 'price_changed':
                            // Prices have changed
                            const priceChanges = discrepancies.priceChanges || [];
                            const changeDetails = priceChanges.map(change => 
                                `${change.filename}: $${change.oldPrice.toFixed(2)} ‚Üí $${change.newPrice.toFixed(2)}`
                            ).join('\n');

                            if (confirm(`${message}\n\n${changeDetails}\n\nWould you like to update your cart with the new prices?`)) {
                                console.log('üîÑ User accepted price changes');
                                await this.reconcileCart();
                                this.updateCartUI();
                                this.showSuccess('Cart updated with new prices. Please review and try checkout again.');
                            } else {
                                console.log('‚ùå User rejected price changes');
                                this.showError('Please review your cart before checkout.');
                            }
                            break;

                        case 'ui_out_of_sync':
                            // Items on backend but not in UI - sync automatically
                            console.log('üîÑ Auto-syncing cart - items on backend but not in UI');
                            await this.reconcileCart();
                            this.updateCartUI();
                            this.showSuccess('Cart has changed. Refreshing...');

                            // Auto-retry checkout after sync
                            setTimeout(() => {
                                this.proceedToCheckout();
                            }, 1500);
                            break;

                        case 'backend_error':
                            // Backend error
                            this.showError(`${message}\n\nPlease try again in a moment.`);
                            break;

                        default:
                            // Unknown error - offer reconciliation
                            if (confirm(`${message}\n\nWould you like to refresh your cart?`)) {
                                await this.reconcileCart();
                                this.updateCartUI();
                                this.showSuccess('Cart refreshed. Please try checkout again.');
                            }
                            break;
                    }
                } finally {
                    // Reset button state
                    if (checkoutBtn) {
                        checkoutBtn.disabled = false;
                        checkoutBtn.textContent = originalText;
                    }
                }
            }

            /**
             * Fetch cart status from backend
             * Returns current cart reservations and quota information
             */
            async fetchCartStatus() {
                try {
                    if (!this.sessionData?.id) {
                        console.warn('‚ö†Ô∏è Cannot fetch cart status - session data not loaded');
                        return { success: false, error: 'Session data not available', networkError: false };
                    }

                    const clientKey = this.getClientKey();
                    console.log(`üîÑ Fetching cart status from backend for session ${this.sessionData.id}...`);

                    // Add timeout handling (10 seconds)
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 10000);

                    try {
                        const response = await fetch(
                            `${this.getApiBaseUrl()}/api/downloads/cart/status?sessionId=${encodeURIComponent(this.sessionData.id)}&clientKey=${encodeURIComponent(clientKey)}`,
                            {
                                method: 'GET',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                signal: controller.signal
                            }
                        );

                        clearTimeout(timeoutId);

                        const data = await response.json();

                        if (response.ok && data.success) {
                            console.log(`‚úÖ Cart status fetched successfully:`, {
                                cartItems: data.cart?.items?.length || data.cartReservations?.length || 0,
                                quotaInfo: data.quota || data.quotaInfo
                            });

                            return {
                                success: true,
                                backendAvailable: true,
                                cart: data.cart || { items: data.cartReservations || [] },
                                quota: data.quota || data.quotaInfo,
                                policy: data.policy,
                                entitlements: data.entitlements || []
                            };
                        } else {
                            console.warn('‚ö†Ô∏è Backend returned error:', data.error);
                            return { 
                                success: false, 
                                backendAvailable: true,
                                error: data.error || 'Failed to fetch cart status',
                                networkError: false
                            };
                        }
                    } catch (fetchError) {
                        clearTimeout(timeoutId);

                        // Distinguish between network errors and other errors
                        const isNetworkError = fetchError.name === 'AbortError' || 
                                              fetchError.message.includes('fetch') ||
                                              fetchError.message.includes('network');

                        if (fetchError.name === 'AbortError') {
                            console.error('‚ùå Cart status fetch timed out after 10 seconds');
                        } else {
                            console.error('‚ùå Network error fetching cart status:', fetchError);
                        }

                        return { 
                            success: false, 
                            backendAvailable: false,
                            error: fetchError.message,
                            networkError: true
                        };
                    }
                } catch (error) {
                    console.error('‚ùå Unexpected error in fetchCartStatus:', error);
                    return { 
                        success: false, 
                        backendAvailable: false,
                        error: error.message,
                        networkError: true
                    };
                }
            }

            /**
             * Reconcile backend cart state with localStorage
             * Ensures consistency between server and client cart states
             * CRITICAL: Only clears cart if backend explicitly confirms no reservations
             * Preserves cart on network errors and failures
             */
            async reconcileCart() {
                try {
                    console.log('üîÑ Starting cart reconciliation...');

                    // Fetch current cart status from backend
                    const backendStatus = await this.fetchCartStatus();

                    // CRITICAL FIX #1: Don't wipe cart on backend failures
                    // Only reconcile if backend is explicitly available and successful
                    if (!backendStatus.success || !backendStatus.backendAvailable) {
                        if (backendStatus.networkError) {
                            console.warn('‚ö†Ô∏è CART PRESERVED: Backend unavailable due to network error - keeping localStorage cart intact');
                            this.showNotification('Cart preserved locally - backend temporarily unavailable', 'warning');
                        } else {
                            console.warn('‚ö†Ô∏è CART PRESERVED: Backend returned error - keeping localStorage cart intact');
                            this.showNotification('Cart sync failed - your cart is safe locally', 'warning');
                        }

                        // Update UI with current local cart state
                        this.updateCartUI();
                        this.photos.forEach(photo => {
                            // STANDARDIZED: Use filename as photoId
                            const isInCart = this.cart.some(item => item.photoId === photo.filename);
                            this.updatePhotoCardUI(photo.filename, isInCart);
                        });

                        return { 
                            success: false, 
                            message: 'Backend unavailable - cart preserved locally',
                            cartPreserved: true
                        };
                    }

                    // Backend is available and successful - proceed with reconciliation
                    console.log('‚úÖ Backend available - proceeding with cart reconciliation');

                    // Get backend cart items (handle both enhanced and legacy response formats)
                    const backendItems = backendStatus.cart?.items || [];
                    const localItems = this.cart || [];

                    console.log(`üìä Reconciliation state:`, {
                        backendItemCount: backendItems.length,
                        localItemCount: localItems.length,
                        backendAvailable: true
                    });

                    // Track changes for UI updates
                    let itemsAdded = 0;
                    let itemsRemoved = 0;
                    let itemsMatched = 0;
                    let reservationsFailed = [];

                    // Create maps for efficient lookup
                    const backendMap = new Map();
                    backendItems.forEach(item => {
                        backendMap.set(item.photoId, item);
                    });

                    const localMap = new Map();
                    localItems.forEach(item => {
                        localMap.set(item.photoId, item);
                    });

                    // Step 1: Add backend items that are missing from localStorage
                    for (const [photoId, backendItem] of backendMap) {
                        if (!localMap.has(photoId)) {
                            console.log(`‚ûï Adding missing item from backend: ${backendItem.filename}`);
                            this.cart.push({
                                photoId: backendItem.photoId,
                                photoUrl: backendItem.photoUrl,
                                filename: backendItem.filename,
                                price: backendItem.price || 0,
                                reservationId: backendItem.reservationId || backendItem.id
                            });
                            itemsAdded++;
                        } else {
                            // Item exists in both - update reservation ID if needed
                            const localItem = localMap.get(photoId);
                            if (!localItem.reservationId && backendItem.reservationId) {
                                localItem.reservationId = backendItem.reservationId || backendItem.id;
                            }
                            itemsMatched++;
                        }
                    }

                    // CRITICAL FIX #2: Only reserve NEW items not already on backend
                    // Don't re-reserve items that already exist
                    // Step 2: Handle localStorage items that are missing from backend
                    const newItemsToReserve = [];
                    const itemsToRemove = [];

                    for (const [photoId, localItem] of localMap) {
                        if (!backendMap.has(photoId)) {
                            console.log(`üîç Local item not on backend: ${localItem.filename}`);

                            // Check if photo still exists in gallery
                            const photo = this.photos.find(p => p.filename === photoId || p.id === photoId);
                            if (photo) {
                                // Queue for reservation attempt
                                newItemsToReserve.push({ photoId, localItem, photo });
                            } else {
                                console.warn(`‚ö†Ô∏è Photo not found in gallery: ${photoId} - removing from cart`);
                                itemsToRemove.push(photoId);
                                itemsRemoved++;
                            }
                        }
                    }

                    // CRITICAL FIX #3: Better error handling for reservations
                    // Only remove items if backend explicitly rejects them (not on network errors)
                    if (newItemsToReserve.length > 0) {
                        console.log(`üîÑ Attempting to reserve ${newItemsToReserve.length} new items on backend...`);

                        for (const { photoId, localItem, photo } of newItemsToReserve) {
                            try {
                                console.log(`üì§ Reserving: ${localItem.filename}`);

                                // Add timeout for individual reservation requests
                                const controller = new AbortController();
                                const timeoutId = setTimeout(() => controller.abort(), 8000);

                                const response = await fetch(`${this.getApiBaseUrl()}/api/downloads/cart/add-item`, {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json'
                                    },
                                    body: JSON.stringify({
                                        sessionId: this.sessionData.id,
                                        clientKey: this.getClientKey(),
                                        photoId: photoId,
                                        photoUrl: localItem.photoUrl,
                                        filename: localItem.filename
                                    }),
                                    signal: controller.signal
                                });

                                clearTimeout(timeoutId);
                                const addResult = await response.json();

                                if (response.ok && addResult.success) {
                                    console.log(`‚úÖ Successfully reserved: ${localItem.filename}`);
                                    // Update local item with reservation ID
                                    localItem.reservationId = addResult.reservationId;
                                    itemsMatched++;
                                } else {
                                    // Backend explicitly rejected - remove from cart
                                    console.warn(`‚ö†Ô∏è Backend explicitly rejected reservation: ${addResult.error || 'Unknown error'}`);
                                    itemsToRemove.push(photoId);
                                    reservationsFailed.push({ filename: localItem.filename, reason: addResult.error });
                                    itemsRemoved++;
                                }
                            } catch (error) {
                                // Network error or timeout - KEEP the item in cart
                                if (error.name === 'AbortError') {
                                    console.warn(`‚ö†Ô∏è CART PRESERVED: Reservation timeout for ${localItem.filename} - keeping in cart`);
                                } else {
                                    console.warn(`‚ö†Ô∏è CART PRESERVED: Network error reserving ${localItem.filename} - keeping in cart:`, error.message);
                                }
                                // Don't remove item - let user try again later
                                itemsMatched++;
                            }
                        }
                    }

                    // Remove items that were explicitly rejected by backend
                    if (itemsToRemove.length > 0) {
                        console.log(`üóëÔ∏è Removing ${itemsToRemove.length} items that backend rejected or don't exist`);
                        this.cart = this.cart.filter(item => !itemsToRemove.includes(item.photoId));
                    }

                    // Step 3: Update localStorage with reconciled state
                    this.saveCart();

                    console.log(`‚úÖ Cart reconciliation complete:`, {
                        itemsAdded,
                        itemsRemoved,
                        itemsMatched,
                        finalCartSize: this.cart.length,
                        reservationsFailed: reservationsFailed.length
                    });

                    // Show notification if some reservations failed
                    if (reservationsFailed.length > 0) {
                        this.showNotification(
                            `${reservationsFailed.length} item(s) could not be reserved and were removed`, 
                            'warning'
                        );
                    }

                    // Step 4: Update UI to reflect reconciled state
                    this.updateCartUI();

                    // Update all photo cards to reflect in-cart status
                    this.photos.forEach((photo) => {
                        const photoId = photo.filename || photo.id;
                        const isInCart = this.cart.some(item => item.photoId === photoId);
                        this.updatePhotoCardUI(photoId, isInCart);
                    });

                    // Update quota display if available
                    if (backendStatus.quota) {
                        this.updateQuotaDisplay(backendStatus.quota);
                    }

                    return {
                        success: true,
                        changes: {
                            itemsAdded,
                            itemsRemoved,
                            itemsMatched
                        }
                    };

                } catch (error) {
                    console.error('‚ùå Unexpected error during cart reconciliation:', error);
                    console.warn('‚ö†Ô∏è CART PRESERVED: Keeping localStorage cart intact due to unexpected error');

                    // Show notification but don't wipe cart
                    this.showNotification('Cart sync error - your cart is safe', 'error');

                    return { 
                        success: false, 
                        error: error.message,
                        cartPreserved: true
                    };
                }
            }

            saveClientInfo() {
                localStorage.setItem('clientEmail', this.clientEmail || '');
                localStorage.setItem('clientName', this.clientName || '');
            }

            loadClientInfo() {
                this.clientEmail = localStorage.getItem('clientEmail') || null;
                this.clientName = localStorage.getItem('clientName') || null;
            }

            /**
             * Generate or load unique visitor ID for proper quota tracking
             * This ensures each browser tab/visitor gets separate download quotas
             */
            generateUniqueVisitorId() {
                // Try to load existing visitor ID from localStorage
                let visitorId = localStorage.getItem('uniqueVisitorId');

                if (!visitorId) {
                    // Generate a new UUID for this visitor
                    visitorId = 'visitor-' + this.generateUUID();
                    localStorage.setItem('uniqueVisitorId', visitorId);
                    console.log(`üÜî Generated new unique visitor ID: ${visitorId}`);
                } else {
                    console.log(`üÜî Loaded existing visitor ID: ${visitorId}`);
                }

                this.uniqueVisitorId = visitorId;
            }

            /**
             * Generate a random UUID v4
             */
            generateUUID() {
                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                    const r = Math.random() * 16 | 0;
                    const v = c === 'x' ? r : (r & 0x3 | 0x8);
                    return v.toString(16);
                });
            }

            /**
             * Get the unique client key for this visitor
             * For freemium galleries, ALWAYS use gallery-session-based key that matches server logic
             */
            getClientKey() {
                // CRITICAL: For freemium mode, ALWAYS use cached gallery client key
                // This ensures consistency with server-side entitlement verification
                if (this.policy && this.policy.mode === 'freemium') {
                    if (this.cachedGalleryClientKey) {
                        return this.cachedGalleryClientKey;
                    } else {
                        console.warn('‚ö†Ô∏è Gallery client key not cached! This will cause entitlement mismatches.');
                        // Emergency fallback - this should not happen if initialization is correct
                        return 'gallery-emergency-fallback';
                    }
                }

                // For non-freemium modes (paid downloads), use email if provided, otherwise visitor ID
                // Ensure a fallback is always provided
                return this.clientEmail || this.uniqueVisitorId || 'anonymous';
            }

            /**
             * UNIFIED API: Validate gallery access and get session data
             * Uses the new /api/downloads/unified/validate-access endpoint
             */
            async validateUnifiedAccess() {
                try {
                    if (!this.galleryToken) {
                        return {
                            success: false,
                            error: 'No gallery token provided'
                        };
                    }

                    console.log('üîê Validating access using unified API...');

                    const response = await fetch(`${this.getApiBaseUrl()}/api/downloads/unified/validate-access`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            galleryAccessToken: this.galleryToken
                            // sessionId removed - server will resolve it from the gallery token
                        })
                    });

                    const data = await response.json();

                    if (response.ok && data.success) {
                        console.log('‚úÖ Unified access validation successful');

                        // Store the session data and policy from the unified response
                        this.sessionData = {
                            id: data.session.id,
                            clientName: data.session.clientName,
                            downloadEnabled: data.session.downloadEnabled,
                            galleryExpiresAt: data.session.galleryExpiresAt
                        };

                        this.policy = data.policy;
                        this.cachedGalleryClientKey = data.clientKey; // Store client key for freemium mode

                        return {
                            success: true,
                            data: {
                                success: true,
                                session: this.sessionData,
                                policy: this.policy,
                                clientKey: data.clientKey,
                                photos: data.photos || [] // Photos are at the root level of the unified API response
                            }
                        };
                    } else {
                        console.error('‚ùå Unified access validation failed:', data.error);
                        return {
                            success: false,
                            error: data.error || 'Access validation failed',
                            code: data.code
                        };
                    }
                } catch (error) {
                    console.error('‚ùå Error during unified access validation:', error);
                    return {
                        success: false,
                        error: 'Network error during access validation'
                    };
                }
            }

            /**
             * UNIFIED API: Process download using the new unified endpoint
             */
            async processUnifiedDownload(photoId, photoUrl, filename, isPaid = false, paymentIntentId = null) {
                try {
                    console.log(`üéØ Processing unified download for photo ${photoId}`);

                    const response = await fetch(`${this.getApiBaseUrl()}/api/downloads/unified/process`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            galleryAccessToken: this.galleryToken,
                            sessionId: this.sessionData.id,
                            photoId: photoId,
                            photoUrl: photoUrl,
                            filename: filename,
                            paymentIntentId: paymentIntentId, // For paid downloads
                            clientKey: this.getClientKey() // Crucial for freemium entitlement tracking
                        })
                    });

                    const data = await response.json();

                    if (response.ok && data.success) {
                        console.log('‚úÖ Unified download processed successfully');
                        return {
                            success: true,
                            downloadToken: data.downloadToken,
                            expiresIn: data.expiresIn,
                            pricing: data.pricing, // Contains model, cost, quota info
                            watermark: data.watermark
                        };
                    } else {
                        console.error('‚ùå Unified download processing failed:', data.error);
                        return {
                            success: false,
                            error: data.error || 'Download processing failed',
                            code: data.code,
                            paymentInfo: data.paymentInfo // For payment required scenarios
                        };
                    }
                } catch (error) {
                    console.error('‚ùå Error during unified download processing:', error);
                    return {
                        success: false,
                        error: 'Network error during download processing'
                    };
                }
            }

            /**
             * UNIFIED API: Get session status and quota information
             */
            async getUnifiedSessionStatus() {
                try {
                    if (!this.sessionData?.id || !this.galleryToken) {
                        throw new Error('Missing session ID or gallery token for unified status check');
                    }

                    // Pass clientKey for accurate quota and entitlement checks, especially for freemium
                    const clientKey = this.getClientKey();

                    const response = await fetch(`${this.getApiBaseUrl()}/api/downloads/unified/status/${this.sessionData.id}?galleryAccessToken=${encodeURIComponent(this.galleryToken)}&clientKey=${encodeURIComponent(clientKey)}`, {
                        method: 'GET'
                    });

                    const data = await response.json();

                    if (response.ok && data.success) {
                        console.log('‚úÖ Session status retrieved successfully');
                        return {
                            success: true,
                            quota: data.quota, // Current quota details
                            policy: data.policy, // Updated policy if changed
                            entitlements: data.entitlements, // Updated entitlements
                            downloads: data.downloads // List of completed downloads
                        };
                    } else {
                        console.error('‚ùå Failed to get session status:', data.error);
                        return {
                            success: false,
                            error: data.error || 'Failed to retrieve session status'
                        };
                    }
                } catch (error) {
                    console.error('‚ùå Error getting session status:', error);
                    return {
                        success: false,
                        error: 'Network error while checking session status'
                    };
                }
            }

            /**
             * Helper to update button states (e.g., disabling, changing text)
             */
            updateButtonState(photoId, text, disabled = false, inCart = false) {
                const button = document.querySelector(`.photo-card[data-photo-id="${photoId}"] .add-to-cart-btn`);
                if (button) {
                    button.textContent = text;
                    button.disabled = disabled;
                    button.classList.toggle('in-cart', inCart);
                }
            }
            
            /**
             * AUTHORITATIVE CLIENT KEY GENERATION
             * Generate client key using IDENTICAL logic to server
             * CRITICAL: Must match server's generateGalleryClientKey function exactly
             */
            async generateGalleryClientKey(galleryAccessToken, sessionId) {
                if (!galleryAccessToken || !sessionId) {
                    throw new Error('Gallery token and session ID are required for client key generation');
                }

                // CRITICAL: Use ONLY gallery token + session ID (no IP, no user agent, no other identifiers)
                // This ensures both server and client can generate the exact same key deterministically
                const baseString = `${galleryAccessToken}-${sessionId}`;

                // Create a SHA-256 hash for the final client key
                const hashHex = await this.sha256(baseString);
                const clientKey = `gallery-${hashHex.substring(0, 16)}`;

                console.log(`üîë Generated authoritative client key: ${clientKey} for gallery token: ${galleryAccessToken.substring(0, 8)}...`);

                return clientKey;
            }

            /**
             * Simple SHA-256 implementation for client-side key generation
             */
            async sha256(message) {
                // Use Web Crypto API for SHA-256 hashing
                const msgBuffer = new TextEncoder().encode(message);
                const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                return hashHex;
            }
        }

        // Initialize cart when page loads
        let galleryCart;
        console.log('üéØ Setting up DOMContentLoaded listener...');

        document.addEventListener('DOMContentLoaded', () => {
            console.log('üìÑ DOM Content Loaded - Initializing gallery...');
            try {
                galleryCart = new ClientGalleryCart();
                console.log('‚úÖ Gallery cart initialized successfully');
            } catch (error) {
                console.error('‚ùå Failed to initialize gallery cart:', error);
                console.error('‚ùå Stack trace:', error.stack);
                // Display error on page
                const errorDiv = document.getElementById('errorContainer');
                if (errorDiv) {
                    errorDiv.style.display = 'block';
                    document.getElementById('errorMessage').textContent = 'Failed to initialize gallery: ' + error.message;
                }
            }
        });

        // Clean up real-time connections when page unloads
        window.addEventListener('beforeunload', () => {
            if (galleryCart && typeof galleryCart.disconnectRealTimeUpdates === 'function') {
                galleryCart.disconnectRealTimeUpdates();
            }
        });

        console.log('üéØ Gallery JavaScript fully loaded');
    </script>
</body>
</html>
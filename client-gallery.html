<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Photo Gallery - Shopping Cart</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
            position: relative;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            opacity: 0.9;
            z-index: -1;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        /* Header Styles */
        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 40px;
            border-radius: 20px;
            margin-bottom: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.15), 0 0 0 1px rgba(255,255,255,0.2);
            text-align: center;
            position: relative;
            overflow: hidden;
        }
        
        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, #667eea, transparent);
            animation: shimmer 3s infinite;
        }
        
        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .header h1 {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 15px;
            font-size: 2.8rem;
            font-weight: 700;
            letter-spacing: -0.02em;
        }

        .header p {
            color: #64748b;
            font-size: 1.2rem;
            font-weight: 500;
            opacity: 0.8;
        }

        /* Pricing Info Banner */
        .pricing-banner {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.95) 0%, rgba(118, 75, 162, 0.95) 100%);
            color: white;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 30px;
            text-align: center;
            font-size: 1.1rem;
            font-weight: 600;
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3);
            display: none;
        }
        
        .pricing-banner.show {
            display: block;
            animation: slideDown 0.5s ease;
        }
        
        /* Enhanced pricing mode visual indicators */
        .pricing-banner.free-mode {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.95) 0%, rgba(101, 163, 13, 0.95) 100%);
        }
        
        .pricing-banner.paid-mode {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.95) 0%, rgba(185, 28, 28, 0.95) 100%);
        }
        
        .pricing-banner.freemium-mode.freemium-free {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.95) 0%, rgba(34, 197, 94, 0.95) 100%);
        }
        
        .pricing-banner.freemium-mode.freemium-paid {
            background: linear-gradient(135deg, rgba(245, 101, 101, 0.95) 0%, rgba(251, 146, 60, 0.95) 100%);
        }
        
        .pricing-banner.bulk-mode {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.95) 0%, rgba(124, 58, 237, 0.95) 100%);
        }
        
        .pricing-banner.rate-limited {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Gallery Actions */
        .gallery-actions {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            padding: 25px;
            border-radius: 18px;
            margin-bottom: 35px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1), 0 0 0 1px rgba(255,255,255,0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
            position: sticky;
            top: 20px;
            z-index: 10;
        }

        .photo-count {
            font-weight: 700;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .photo-count::before {
            content: '📸';
            font-size: 1.5rem;
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .select-all-btn {
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 12px;
            font-weight: 700;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 8px 25px rgba(139, 92, 246, 0.3);
        }

        .select-all-btn:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 12px 35px rgba(139, 92, 246, 0.4);
        }

        /* Gallery Grid */
        .gallery-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 25px;
            margin-bottom: 40px;
            padding: 0 5px;
        }

        /* Photo Card */
        .photo-card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1), 0 0 0 1px rgba(255,255,255,0.2);
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            cursor: pointer;
            position: relative;
        }

        .photo-card.in-cart {
            box-shadow: 0 10px 40px rgba(102, 126, 234, 0.3), 0 0 0 3px rgba(102, 126, 234, 0.5);
        }

        .photo-card:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 0 25px 60px rgba(0,0,0,0.15), 0 0 0 1px rgba(102, 126, 234, 0.1);
        }

        .photo-wrapper {
            position: relative;
            width: 100%;
            overflow: hidden;
            aspect-ratio: 4/3;
            background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
        }

        .photo-wrapper img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .photo-card:hover .photo-wrapper img {
            transform: scale(1.08) rotate(0.5deg);
        }

        /* Removed redundant cart indicator - button state handles this */

        /* Price Badge */
        .price-badge {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 8px 15px;
            border-radius: 25px;
            font-weight: 700;
            font-size: 0.95rem;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            z-index: 10;
        }

        .price-badge.free {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
        }

        .price-badge.paid {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
        }

        /* Photo Info */
        .photo-info {
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            position: relative;
            z-index: 2;
        }

        .photo-filename {
            font-weight: 700;
            color: #2d3748;
            font-size: 1.1rem;
            letter-spacing: -0.01em;
            line-height: 1.3;
            margin: 0;
        }

        .photo-actions {
            display: flex;
            gap: 10px;
        }

        .photo-btn {
            flex: 1;
            padding: 12px 18px;
            border: none;
            border-radius: 12px;
            font-size: 0.95rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            overflow: hidden;
        }

        .add-to-cart-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .add-to-cart-btn:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }

        .add-to-cart-btn.in-cart {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            box-shadow: 0 4px 15px rgba(245, 158, 11, 0.3);
        }
        
        .add-to-cart-btn.in-cart:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 8px 25px rgba(245, 158, 11, 0.4);
        }

        .download-btn {
            background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(72, 187, 120, 0.3);
        }

        .download-btn:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 8px 25px rgba(72, 187, 120, 0.4);
        }

        .download-btn.immediate.free {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.3);
        }

        .download-btn.immediate.free:hover {
            box-shadow: 0 8px 25px rgba(16, 185, 129, 0.4);
        }

        .download-btn.immediate.free.quota-exhausted {
            background: linear-gradient(135deg, #9ca3af 0%, #6b7280 100%);
            color: #f3f4f6;
            box-shadow: 0 4px 15px rgba(156, 163, 175, 0.3);
            cursor: not-allowed;
            opacity: 0.7;
        }

        .download-btn.immediate.free.quota-exhausted:hover {
            transform: none;
            box-shadow: 0 4px 15px rgba(156, 163, 175, 0.3);
        }

        .download-btn.immediate.paid {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            box-shadow: 0 4px 15px rgba(245, 158, 11, 0.3);
        }

        .download-btn.immediate.paid:hover {
            box-shadow: 0 8px 25px rgba(245, 158, 11, 0.4);
        }

        /* Floating Cart Icon */
        .floating-cart {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 70px;
            height: 70px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 30px;
            cursor: pointer;
            box-shadow: 0 10px 40px rgba(102, 126, 234, 0.5), 0 0 0 3px rgba(255,255,255,0.3);
            transition: all 0.3s ease;
            z-index: 1000;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 10px 40px rgba(102, 126, 234, 0.5), 0 0 0 3px rgba(255,255,255,0.3); }
            50% { box-shadow: 0 10px 40px rgba(102, 126, 234, 0.7), 0 0 0 6px rgba(255,255,255,0.1); }
            100% { box-shadow: 0 10px 40px rgba(102, 126, 234, 0.5), 0 0 0 3px rgba(255,255,255,0.3); }
        }

        .floating-cart:hover {
            transform: scale(1.1);
            box-shadow: 0 15px 50px rgba(102, 126, 234, 0.6), 0 0 0 3px rgba(255,255,255,0.4);
        }

        .cart-count {
            position: absolute;
            top: -5px;
            right: -5px;
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: 700;
            box-shadow: 0 4px 15px rgba(239, 68, 68, 0.5);
        }

        /* Cart Drawer */
        .cart-drawer {
            position: fixed;
            top: 0;
            right: -450px;
            width: 450px;
            height: 100%;
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(20px);
            box-shadow: -10px 0 50px rgba(0,0,0,0.2);
            transition: right 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 2000;
            display: flex;
            flex-direction: column;
        }

        .cart-drawer.open {
            right: 0;
        }

        .cart-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(5px);
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            z-index: 1999;
        }

        .cart-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .cart-header {
            padding: 25px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .cart-title {
            font-size: 1.5rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .close-cart {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 20px;
        }

        .close-cart:hover {
            background: rgba(255,255,255,0.3);
            transform: scale(1.1);
        }

        .cart-items {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .cart-empty {
            text-align: center;
            padding: 60px 20px;
            color: #94a3b8;
        }

        .cart-empty-icon {
            font-size: 60px;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        .cart-item {
            display: flex;
            gap: 15px;
            padding: 15px;
            background: rgba(248, 250, 252, 0.9);
            border-radius: 15px;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }

        .cart-item:hover {
            background: rgba(241, 245, 249, 1);
            transform: translateX(-5px);
        }

        .cart-item-image {
            width: 80px;
            height: 80px;
            border-radius: 10px;
            overflow: hidden;
            flex-shrink: 0;
        }

        .cart-item-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .cart-item-details {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .cart-item-name {
            font-weight: 600;
            color: #2d3748;
            margin-bottom: 5px;
            font-size: 0.95rem;
        }

        .cart-item-price {
            font-weight: 700;
            color: #667eea;
            font-size: 1.1rem;
        }

        .cart-item-remove {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
            border: none;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            align-self: center;
        }

        .cart-item-remove:hover {
            transform: scale(1.1);
            box-shadow: 0 5px 20px rgba(239, 68, 68, 0.4);
        }

        /* Cart Footer */
        .cart-footer {
            padding: 20px;
            background: rgba(248, 250, 252, 0.95);
            border-top: 1px solid rgba(226, 232, 240, 0.8);
        }

        .cart-total {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: white;
            border-radius: 12px;
        }

        .cart-total-label {
            font-weight: 600;
            color: #64748b;
            font-size: 1.1rem;
        }

        .cart-total-amount {
            font-weight: 700;
            font-size: 1.5rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .cart-actions {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .checkout-btn {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border: none;
            padding: 18px;
            border-radius: 12px;
            font-weight: 700;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 8px 25px rgba(16, 185, 129, 0.3);
        }

        .checkout-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 12px 35px rgba(16, 185, 129, 0.4);
        }

        .checkout-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .clear-cart-btn {
            background: rgba(239, 68, 68, 0.1);
            color: #dc2626;
            border: 2px solid #dc2626;
            padding: 12px;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .clear-cart-btn:hover {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
            transform: translateY(-1px);
        }

        /* Client Email Modal */
        .email-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(10px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 3000;
        }

        .email-modal.show {
            display: flex;
        }

        .email-modal-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        .email-modal h2 {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            font-size: 1.8rem;
        }

        .email-modal p {
            color: #64748b;
            margin-bottom: 30px;
            font-size: 1.05rem;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #475569;
        }

        .form-group input {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .form-group input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .form-actions {
            display: flex;
            gap: 12px;
            margin-top: 30px;
        }

        .form-actions button {
            flex: 1;
            padding: 14px;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .submit-email {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .cancel-email {
            background: #f1f5f9;
            color: #64748b;
        }

        /* Success Message */
        .success-message {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            padding: 20px 30px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(16, 185, 129, 0.4);
            display: none;
            align-items: center;
            gap: 15px;
            z-index: 3000;
            animation: slideInRight 0.5s ease;
        }

        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .success-message.show {
            display: flex;
        }

        /* Loading States */
        .loading {
            text-align: center;
            padding: 60px 40px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.1);
            margin: 40px 0;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 5px solid rgba(102, 126, 234, 0.1);
            border-top: 5px solid #667eea;
            border-radius: 50%;
            animation: spin 1.2s cubic-bezier(0.68, -0.55, 0.265, 1.55) infinite;
            margin: 0 auto 25px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Download Manager */
        .download-queue {
            position: fixed;
            bottom: 100px;
            right: 30px;
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.15);
            max-width: 400px;
            display: none;
            z-index: 999;
        }

        .download-queue.show {
            display: block;
            animation: slideUp 0.5s ease;
        }

        @keyframes slideUp {
            from {
                transform: translateY(100%);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .download-queue-title {
            font-weight: 700;
            color: #2d3748;
            margin-bottom: 15px;
            font-size: 1.1rem;
        }

        .download-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: #f8fafc;
            border-radius: 8px;
            margin-bottom: 10px;
        }

        .download-progress {
            width: 100%;
            height: 4px;
            background: #e2e8f0;
            border-radius: 2px;
            overflow: hidden;
            margin-top: 5px;
        }

        .download-progress-bar {
            height: 100%;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            transition: width 0.3s ease;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            body {
                padding: 15px;
            }
            
            .gallery-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .cart-drawer {
                width: 100%;
                right: -100%;
            }
            
            .floating-cart {
                width: 60px;
                height: 60px;
                font-size: 25px;
            }
            
            .header {
                padding: 30px 25px;
            }
            
            .header h1 {
                font-size: 2.2rem;
            }
            
            .gallery-actions {
                flex-direction: column;
                text-align: center;
            }
            
            .action-buttons {
                width: 100%;
                flex-direction: column;
            }
            
            .select-all-btn {
                width: 100%;
            }
        }

        @media (max-width: 480px) {
            .header h1 {
                font-size: 1.8rem;
            }
            
            .cart-drawer {
                padding-top: env(safe-area-inset-top);
            }
        }

        /* Error Styles */
        .error {
            background: linear-gradient(135deg, rgba(254, 215, 215, 0.9) 0%, rgba(252, 129, 129, 0.1) 100%);
            backdrop-filter: blur(10px);
            color: #c53030;
            padding: 30px;
            border-radius: 18px;
            text-align: center;
            margin-bottom: 30px;
            border: 1px solid rgba(197, 48, 48, 0.2);
            box-shadow: 0 10px 40px rgba(197, 48, 48, 0.1);
        }

        /* Quota Display Styles */
        .quota-info {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.1) 0%, rgba(147, 51, 234, 0.05) 100%);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(59, 130, 246, 0.2);
            border-radius: 12px;
            padding: 15px;
            margin: 15px 20px;
            font-size: 14px;
        }

        .quota-text {
            color: #374151;
            font-weight: 500;
            margin-bottom: 8px;
            text-align: center;
        }

        .quota-progress {
            background: rgba(156, 163, 175, 0.2);
            border-radius: 8px;
            height: 8px;
            overflow: hidden;
            position: relative;
        }

        .quota-bar {
            height: 100%;
            border-radius: 8px;
            transition: width 0.3s ease, background 0.3s ease;
            position: relative;
        }

        .quota-bar.quota-good {
            background: linear-gradient(90deg, #10b981 0%, #34d399 100%);
        }

        .quota-bar.quota-medium {
            background: linear-gradient(90deg, #3b82f6 0%, #60a5fa 100%);
        }

        .quota-bar.quota-warning {
            background: linear-gradient(90deg, #f59e0b 0%, #fbbf24 100%);
        }

        .quota-bar.quota-critical {
            background: linear-gradient(90deg, #ef4444 0%, #f87171 100%);
        }

        .quota-bar.quota-exhausted {
            background: linear-gradient(90deg, #dc2626 0%, #ef4444 100%);
            animation: flash 1s infinite;
        }

        .quota-bar.quota-unlimited {
            background: linear-gradient(90deg, #10b981 0%, #34d399 100%);
        }

        .quota-bar.quota-freemium {
            background: linear-gradient(90deg, #22c55e 0%, #3b82f6 100%);
        }

        @keyframes flash {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.5; }
        }

        /* Progress Indicator Styles */
        .progress-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10000;
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            color: white;
            text-align: center;
            min-width: 300px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        .progress-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .progress-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid #3b82f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .progress-message {
            font-size: 16px;
            font-weight: 500;
            margin: 0;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6 0%, #1d4ed8 100%);
            transition: width 0.5s ease;
            border-radius: 4px;
        }

        /* Toast Notification Styles */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10001;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .toast {
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            gap: 12px;
            min-width: 300px;
            max-width: 500px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            animation: toastSlideIn 0.3s ease;
            border-left: 4px solid #3b82f6;
        }

        .toast-success {
            border-left-color: #22c55e;
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.9) 0%, rgba(21, 128, 61, 0.9) 100%);
        }

        .toast-error {
            border-left-color: #ef4444;
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.9) 0%, rgba(185, 28, 28, 0.9) 100%);
        }

        .toast-warning {
            border-left-color: #f59e0b;
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.9) 0%, rgba(217, 119, 6, 0.9) 100%);
        }

        .toast-rate-limit {
            border-left-color: #8b5cf6;
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.9) 0%, rgba(109, 40, 217, 0.9) 100%);
        }

        .toast-network-error {
            border-left-color: #06b6d4;
            background: linear-gradient(135deg, rgba(6, 182, 212, 0.9) 0%, rgba(8, 145, 178, 0.9) 100%);
        }

        .toast-quota-exceeded {
            border-left-color: #f97316;
            background: linear-gradient(135deg, rgba(249, 115, 22, 0.9) 0%, rgba(234, 88, 12, 0.9) 100%);
        }

        .toast-icon {
            font-size: 20px;
            flex-shrink: 0;
        }

        .toast-message {
            flex: 1;
            font-size: 14px;
            line-height: 1.4;
        }

        .toast-close {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            font-size: 18px;
            cursor: pointer;
            padding: 0;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease;
        }

        .toast-close:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        @keyframes toastSlideIn {
            from {
                opacity: 0;
                transform: translateX(100%);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .toast-fade-out {
            animation: toastFadeOut 0.3s ease forwards;
        }

        @keyframes toastFadeOut {
            from {
                opacity: 1;
                transform: translateX(0);
            }
            to {
                opacity: 0;
                transform: translateX(100%);
            }
        }

        /* Quota Modal Styles */
        .quota-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            backdrop-filter: blur(4px);
        }

        .quota-modal {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.25);
            border: 1px solid rgba(255, 255, 255, 0.2);
            overflow: hidden;
        }

        .quota-modal-header {
            background: linear-gradient(135deg, rgba(254, 215, 215, 0.8) 0%, rgba(252, 129, 129, 0.2) 100%);
            padding: 20px;
            text-align: center;
            border-bottom: 1px solid rgba(252, 129, 129, 0.2);
        }

        .quota-modal-header h3 {
            margin: 0;
            color: #c53030;
            font-size: 20px;
        }

        .quota-modal-body {
            padding: 25px;
            line-height: 1.6;
        }

        .quota-details {
            background: rgba(243, 244, 246, 0.5);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
        }

        .quota-details ul {
            margin: 10px 0 0 0;
            padding-left: 20px;
        }

        .quota-details li {
            margin: 5px 0;
        }

        .quota-modal-actions {
            padding: 20px;
            text-align: center;
            border-top: 1px solid rgba(243, 244, 246, 0.8);
        }

        .quota-modal-btn {
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.3);
        }

        .quota-modal-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(59, 130, 246, 0.4);
        }

        .empty-gallery {
            text-align: center;
            padding: 60px 40px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.1);
            margin: 40px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1 id="galleryTitle">Loading Gallery...</h1>
            <p id="gallerySubtitle">Please wait while we load your photos</p>
        </div>

        <!-- Pricing Banner -->
        <div id="pricingBanner" class="pricing-banner">
            <span id="pricingInfo">Loading pricing information...</span>
        </div>

        <!-- Loading State -->
        <div id="loadingContainer" class="loading">
            <div class="loading-spinner"></div>
            <h3>Preparing Your Gallery</h3>
            <p>Loading beautiful memories...</p>
        </div>

        <!-- Error Container -->
        <div id="errorContainer" class="error" style="display: none;">
            <h2>Gallery Access Error</h2>
            <p id="errorMessage">Unable to access this gallery. Please check your link and try again.</p>
        </div>

        <!-- Gallery Actions -->
        <div id="galleryActions" class="gallery-actions" style="display: none;">
            <div class="photo-count" id="photoCount">0 photos</div>
            <div class="action-buttons">
                <button class="select-all-btn" id="selectAllBtn">
                    ✨ Select All Photos
                </button>
            </div>
        </div>

        <!-- Gallery Grid -->
        <div id="galleryGrid" class="gallery-grid"></div>

        <!-- Empty Gallery -->
        <div id="emptyGallery" class="empty-gallery" style="display: none;">
            <h2>No Photos Available</h2>
            <p>This gallery doesn't have any photos available yet. Please check back later.</p>
        </div>
    </div>

    <!-- Floating Cart Icon -->
    <div class="floating-cart" id="floatingCart" style="display: none;">
        🛒
        <span class="cart-count" id="cartCount">0</span>
    </div>

    <!-- Cart Overlay -->
    <div class="cart-overlay" id="cartOverlay"></div>

    <!-- Cart Drawer -->
    <div class="cart-drawer" id="cartDrawer">
        <div class="cart-header">
            <div class="cart-title">
                🛒 Shopping Cart
            </div>
            <button class="close-cart" id="closeCart">✕</button>
        </div>
        
        <!-- Quota Information Display -->
        <div class="quota-info" id="quotaInfo" style="display: none;">
            <div class="quota-text" id="quotaText">Loading quota...</div>
            <div class="quota-progress" id="quotaProgress">
                <div class="quota-bar quota-good" id="quotaBar"></div>
            </div>
        </div>
        
        <div class="cart-items" id="cartItems">
            <div class="cart-empty">
                <div class="cart-empty-icon">🛒</div>
                <h3>Your cart is empty</h3>
                <p>Add photos to start your collection</p>
            </div>
        </div>
        <div class="cart-footer">
            <div class="cart-total">
                <span class="cart-total-label">Total:</span>
                <span class="cart-total-amount" id="cartTotal">$0.00</span>
            </div>
            <div class="cart-actions">
                <button class="checkout-btn" id="checkoutBtn" disabled>
                    Proceed to Checkout
                </button>
                <button class="clear-cart-btn" id="clearCartBtn">
                    Clear Cart
                </button>
            </div>
        </div>
    </div>

    <!-- Client Email Modal -->
    <div class="email-modal" id="emailModal">
        <div class="email-modal-content">
            <h2>Complete Your Order</h2>
            <p>Please provide your email to receive your photos and receipt</p>
            <form id="emailForm">
                <div class="form-group">
                    <label for="clientEmail">Email Address *</label>
                    <input type="email" id="clientEmail" name="email" required placeholder="your@email.com">
                </div>
                <div class="form-group">
                    <label for="clientName">Name (optional)</label>
                    <input type="text" id="clientName" name="name" placeholder="Your Name">
                </div>
                <div class="form-actions">
                    <button type="submit" class="submit-email">Continue to Payment</button>
                    <button type="button" class="cancel-email" id="cancelEmail">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Success Message -->
    <div class="success-message" id="successMessage">
        <span>✓</span>
        <span id="successText">Photo added to cart!</span>
    </div>

    <!-- Download Queue -->
    <div class="download-queue" id="downloadQueue">
        <div class="download-queue-title">Downloads in Progress</div>
        <div id="downloadQueueItems"></div>
    </div>
    
    <!-- Include Screenshot Protection Script -->
    <script src="/static/js/screenshot-protection.js"></script>

    <script>
        // Immediately show JavaScript is running
        document.addEventListener('DOMContentLoaded', function() {
            // Add visual indicator that JavaScript is running
            const indicator = document.createElement('div');
            indicator.style.cssText = 'position:fixed;top:10px;right:10px;background:green;color:white;padding:10px;z-index:9999;border-radius:5px;';
            indicator.textContent = '✅ JavaScript is running!';
            document.body.appendChild(indicator);
        });
        
        // Add immediate debugging
        console.log('🚀 Gallery JavaScript starting to load...');
        
        // Add error handler to catch any issues
        window.addEventListener('error', function(event) {
            console.error('❌ JavaScript Error:', event.error);
            console.error('❌ Error at:', event.filename, 'Line:', event.lineno, 'Col:', event.colno);
            // Also display error on page
            const errorDiv = document.getElementById('errorContainer');
            if (errorDiv) {
                errorDiv.style.display = 'block';
                document.getElementById('errorMessage').textContent = 'JavaScript Error: ' + event.error.message;
            }
        });
        
        // ClientGalleryCart Class
        class ClientGalleryCart {
            constructor() {
                this.cart = [];
                this.entitlements = [];
                this.policy = null;
                this.sessionData = null;
                this.photos = [];
                this.galleryToken = null;
                this.clientEmail = null;
                this.clientName = null;
                this.downloadQueue = [];
                this.uniqueVisitorId = null;
                this.cachedGalleryClientKey = null;
                
                // Initialize from URL - support both path and query parameter patterns
                const urlParams = new URLSearchParams(window.location.search);
                const pathParts = window.location.pathname.split('/');
                
                // Try to get token from URL parameters first (e.g., ?token=abc123)
                this.galleryToken = urlParams.get('token');
                
                // If no token in parameters, extract from URL path 
                if (!this.galleryToken) {
                    // Support patterns like /gallery/token or /g/token
                    const lastPathSegment = pathParts[pathParts.length - 1];
                    if (lastPathSegment && lastPathSegment !== 'client-gallery.html' && lastPathSegment !== '') {
                        this.galleryToken = lastPathSegment;
                    }
                }
                
                console.log('🔑 Extracted gallery token:', this.galleryToken ? 'Found' : 'Not found', 'from', 
                           urlParams.get('token') ? 'URL parameters' : 'URL path');
                
                // Check for success/cancel from Stripe
                this.checkoutStatus = urlParams.get('status');
                this.sessionId = urlParams.get('session_id');
                
                // Bind methods
                this.init = this.init.bind(this);
                this.loadCart = this.loadCart.bind(this);
                this.saveCart = this.saveCart.bind(this);
                this.addToCart = this.addToCart.bind(this);
                this.removeFromCart = this.removeFromCart.bind(this);
                this.updateCartUI = this.updateCartUI.bind(this);
                this.calculateTotal = this.calculateTotal.bind(this);
                this.proceedToCheckout = this.proceedToCheckout.bind(this);
                this.loadEntitlements = this.loadEntitlements.bind(this);
                this.downloadPhoto = this.downloadPhoto.bind(this);
                this.handleCheckoutReturn = this.handleCheckoutReturn.bind(this);
                
                // Initialize
                this.init();
            }
            
            /**
             * Get the correct API base URL for both localhost development and production
             * For localhost development: use current origin (e.g., http://localhost:5000)
             * For production published galleries: use main domain (https://photomanagementsystem.com)
             */
            getApiBaseUrl() {
                const hostname = window.location.hostname;
                
                // For localhost development, use current origin
                if (hostname === 'localhost' || hostname === '127.0.0.1' || hostname.includes('replit')) {
                    return window.location.origin;
                }
                
                // For production published galleries on subdomains, use main domain
                return 'https://photomanagementsystem.com';
            }
            
            async init() {
                console.log('🛒 Initializing ClientGalleryCart...');
                
                // CRITICAL FIX: Generate unique visitor ID for freemium quota tracking
                // Must be done FIRST before any API calls that use getClientKey()
                this.generateUniqueVisitorId();
                console.log('🆔 Visitor ID initialized:', this.uniqueVisitorId);
                
                // Initialize screenshot protection system
                this.initializeProtection();
                
                // Load saved cart and client info
                this.loadCart();
                this.loadClientInfo();
                
                // Setup UI event listeners
                this.setupEventListeners();
                
                // Load gallery data
                await this.loadGallery();
                
                // FREEMIUM FIX: Generate and cache gallery-based client key for freemium mode
                if (this.policy && this.policy.mode === 'freemium' && this.galleryToken && this.sessionData) {
                    this.cachedGalleryClientKey = await this.generateGalleryClientKey(this.galleryToken, this.sessionData.id);
                    console.log(`🔑 Cached gallery client key for freemium mode: ${this.cachedGalleryClientKey}`);
                }
                
                // Recalculate cart prices based on correct freemium logic
                // This fixes any cart items that were saved with incorrect prices
                if (this.cart.length > 0 && this.policy) {
                    console.log('🛒 Recalculating cart prices after loading gallery policy...');
                    this.recalculatePrices();
                }
                
                // Handle checkout return
                if (this.checkoutStatus) {
                    await this.handleCheckoutReturn();
                }
                
                // Load entitlements to check for already purchased photos
                // For freemium galleries, we need to load entitlements even without client email
                // to properly show download buttons for unpurchased photos
                await this.loadEntitlements();

                // Load initial quota status
                await this.loadQuotaStatus();
                
                // Initialize real-time gallery updates after everything is loaded
                this.initializeRealTimeUpdates();
            }
            
            initializeRealTimeUpdates() {
                if (!this.galleryToken) {
                    console.warn('⚠️ No gallery token available for real-time updates');
                    return;
                }
                
                try {
                    console.log('🔄 Initializing real-time gallery updates...');
                    
                    // Create EventSource connection to SSE endpoint
                    this.eventSource = new EventSource(`${this.getApiBaseUrl()}/api/gallery/events?token=${this.galleryToken}`);
                    
                    this.eventSource.onopen = (event) => {
                        console.log('✅ Real-time gallery updates connected');
                    };
                    
                    // Listen for connection confirmation
                    this.eventSource.addEventListener('connected', (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            console.log('📡 SSE connection confirmed:', data);
                        } catch (error) {
                            console.error('❌ Error parsing connection event:', error);
                        }
                    });
                    
                    // Listen for photo updates (server sends 'photos_updated' events)
                    this.eventSource.addEventListener('photos_updated', (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            console.log('📡 Photos updated event received:', data);
                            this.handlePhotosAdded(data);
                        } catch (error) {
                            console.error('❌ Error parsing photos updated event:', error);
                        }
                    });
                    
                    // Listen for gallery refresh events
                    this.eventSource.addEventListener('gallery_refresh', (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            console.log('📡 Gallery refresh event received:', data);
                            this.refreshGallery();
                        } catch (error) {
                            console.error('❌ Error parsing gallery refresh event:', error);
                        }
                    });
                    
                    // Listen for heartbeat events (keep-alive)
                    this.eventSource.addEventListener('heartbeat', (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            console.log('💓 SSE heartbeat received:', data.timestamp);
                        } catch (error) {
                            console.error('❌ Error parsing heartbeat event:', error);
                        }
                    });
                    
                    this.eventSource.onerror = (event) => {
                        console.error('❌ Real-time gallery updates connection error:', event);
                        
                        // Attempt to reconnect after a delay
                        setTimeout(() => {
                            if (this.eventSource.readyState === EventSource.CLOSED) {
                                console.log('🔄 Attempting to reconnect real-time updates...');
                                this.initializeRealTimeUpdates();
                            }
                        }, 5000);
                    };
                } catch (error) {
                    console.error('❌ Failed to initialize real-time updates:', error);
                }
            }
            
            async handlePhotosAdded(data) {
                try {
                    const newPhotosCount = data.newPhotosCount || 0;
                    console.log(`🆕 ${newPhotosCount} new photos added to gallery!`, data);
                    
                    // Show a brief notification to the user
                    if (newPhotosCount > 0) {
                        this.showUpdateNotification(`${newPhotosCount} new photo${newPhotosCount > 1 ? 's' : ''} added!`);
                    }
                    
                    // Refresh the gallery to show new photos
                    await this.refreshGallery();
                    
                } catch (error) {
                    console.error('❌ Error handling photos added:', error);
                }
            }
            
            async refreshGallery() {
                try {
                    console.log('🔄 Refreshing gallery with new photos...');
                    
                    // Re-verify gallery access using unified API
                    const validateResponse = await this.validateUnifiedAccess();
                    
                    if (validateResponse.success && validateResponse.data.session) {
                        const verifyData = validateResponse.data;
                        // Update photos array with new data
                        this.photos = verifyData.photos || [];
                        console.log(`📸 Gallery refreshed: now showing ${this.photos.length} photos`);
                        
                        // Refresh the display
                        this.displayPhotos();
                        
                        // Update UI elements that show photo count
                        const photoCountElements = document.querySelectorAll('.photo-count');
                        photoCountElements.forEach(element => {
                            element.textContent = `${this.photos.length} photo${this.photos.length !== 1 ? 's' : ''}`;
                        });
                        
                        // If gallery was empty before, show gallery actions
                        if (this.photos.length > 0) {
                            document.getElementById('galleryActions').style.display = 'flex';
                            document.getElementById('floatingCart').style.display = 'flex';
                            document.getElementById('emptyGallery').style.display = 'none';
                        }
                    } else {
                        console.warn('⚠️ Failed to refresh gallery data');
                    }
                } catch (error) {
                    console.error('❌ Error refreshing gallery:', error);
                }
            }
            
            showUpdateNotification(message) {
                // Create or update notification element
                let notification = document.getElementById('realtimeNotification');
                if (!notification) {
                    notification = document.createElement('div');
                    notification.id = 'realtimeNotification';
                    notification.style.cssText = `
                        position: fixed;
                        top: 20px;
                        right: 20px;
                        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                        color: white;
                        padding: 15px 20px;
                        border-radius: 10px;
                        box-shadow: 0 8px 32px rgba(0,0,0,0.2);
                        z-index: 10000;
                        font-weight: 600;
                        opacity: 0;
                        transform: translateY(-20px);
                        transition: all 0.3s ease;
                    `;
                    document.body.appendChild(notification);
                }
                
                notification.textContent = message;
                
                // Show notification
                requestAnimationFrame(() => {
                    notification.style.opacity = '1';
                    notification.style.transform = 'translateY(0)';
                });
                
                // Hide notification after 3 seconds
                setTimeout(() => {
                    notification.style.opacity = '0';
                    notification.style.transform = 'translateY(-20px)';
                }, 3000);
            }
            
            // Clean up EventSource on page unload
            disconnectRealTimeUpdates() {
                if (this.eventSource) {
                    console.log('🔌 Disconnecting real-time gallery updates');
                    this.eventSource.close();
                    this.eventSource = null;
                }
            }
            
            initializeProtection() {
                // Initialize screenshot protection if available
                if (window.ScreenshotProtection) {
                    this.protection = new ScreenshotProtection();
                    console.log('🛡️ Screenshot protection initialized');
                } else {
                    console.warn('⚠️ Screenshot protection module not loaded');
                }
            }
            
            setupEventListeners() {
                // Cart toggle
                const floatingCart = document.getElementById('floatingCart');
                const closeCart = document.getElementById('closeCart');
                const cartOverlay = document.getElementById('cartOverlay');
                
                floatingCart?.addEventListener('click', () => this.openCart());
                closeCart?.addEventListener('click', () => this.closeCart());
                cartOverlay?.addEventListener('click', () => this.closeCart());
                
                // Cart actions
                document.getElementById('checkoutBtn')?.addEventListener('click', () => this.proceedToCheckout());
                document.getElementById('clearCartBtn')?.addEventListener('click', () => this.clearCart());
                
                // Select all button
                document.getElementById('selectAllBtn')?.addEventListener('click', () => this.selectAllPhotos());
                
                // Email modal
                document.getElementById('emailForm')?.addEventListener('submit', (e) => this.handleEmailSubmit(e));
                document.getElementById('cancelEmail')?.addEventListener('click', () => this.closeEmailModal());
                
                // Mobile swipe to close cart
                let startX = 0;
                const cartDrawer = document.getElementById('cartDrawer');
                
                cartDrawer?.addEventListener('touchstart', (e) => {
                    startX = e.touches[0].clientX;
                });
                
                cartDrawer?.addEventListener('touchend', (e) => {
                    const endX = e.changedTouches[0].clientX;
                    if (endX - startX > 100) { // Swipe right
                        this.closeCart();
                    }
                });
            }
            
            async loadGallery() {
                try {
                    console.log('📸 Loading gallery with token:', this.galleryToken);
                    
                    // Use new unified API for gallery access validation
                    const validateResponse = await this.validateUnifiedAccess();
                    
                    if (!validateResponse.success) {
                        console.error('❌ Gallery access validation failed:', validateResponse.error);
                        this.showError(validateResponse.error || 'Unable to access gallery');
                        return;
                    }
                    
                    const verifyData = validateResponse.data;
                    console.log('🔍 Unified API Response received:', verifyData);
                    console.log('🔍 API Response data structure:', JSON.stringify(verifyData, null, 2));
                    
                    if (!verifyData.success || !verifyData) {
                        throw new Error(verifyData?.error || 'Gallery access denied');
                    }
                    
                    // Check if we have success and session data
                    if (!verifyData.success || !verifyData.session) {
                        console.error('❌ Invalid API response structure:', verifyData);
                        throw new Error('Invalid gallery response structure');
                    }
                    
                    const sessionData = verifyData.session;
                    console.log('🔍 Session data extracted:', sessionData);
                    
                    // Extract session data from the response (photos are included)
                    this.sessionData = {
                        id: verifyData.sessionId || sessionData.id,
                        clientName: sessionData.clientName,
                        sessionName: sessionData.sessionName || 'Photo Gallery',
                        sessionDate: sessionData.sessionDate || new Date().toISOString(),
                        downloadEnabled: sessionData.downloadEnabled,
                        pricingModel: sessionData.pricingModel,
                        downloadMax: sessionData.downloadMax,
                        pricePerDownload: sessionData.pricePerDownload,
                        freeDownloads: sessionData.freeDownloads
                    };
                    console.log('✅ Gallery verified:', this.sessionData);
                    
                    // Load policy from session data to enable freemium mode
                    await this.loadPolicy();
                    console.log('🔧 Policy loaded:', this.policy);
                    
                    // FIX: Photos are in verifyData.photos, not sessionData.photos
                    this.photos = verifyData.photos || [];
                    console.log(`📸 Photos array found:`, this.photos);
                    console.log(`📸 Loaded ${this.photos.length} photos`);
                    
                    // Debug each photo
                    this.photos.forEach((photo, index) => {
                        console.log(`📸 Photo ${index + 1}:`, {
                            id: photo.id,
                            filename: photo.filename,
                            url: photo.url,
                            hasUrl: !!photo.url,
                            hasFilename: !!photo.filename
                        });
                    });
                    
                    // Get download policy
                    await this.loadPolicy();
                    
                    // Update UI
                    this.updateGalleryUI();
                    await this.updatePricingBanner();
                    this.displayPhotos();
                    
                    // Hide loading, show gallery
                    document.getElementById('loadingContainer').style.display = 'none';
                    if (this.photos.length > 0) {
                        console.log('✅ Showing gallery with photos');
                        document.getElementById('galleryActions').style.display = 'flex';
                        document.getElementById('floatingCart').style.display = 'flex';
                    } else {
                        console.warn('⚠️ No photos found, showing empty gallery');
                        document.getElementById('emptyGallery').style.display = 'block';
                    }
                    
                } catch (error) {
                    console.error('❌ Error loading gallery:', error);
                    console.error('❌ Error stack:', error.stack);
                    console.error('❌ Token being used:', this.galleryToken);
                    
                    // CRITICAL DEBUG: Try to force the gallery to work even with errors
                    console.log('🔄 ATTEMPTING EMERGENCY GALLERY RECOVERY...');
                    
                    try {
                        // Make one more direct API call using unified endpoint
                        const emergencyResponse = await this.validateUnifiedAccess();
                        
                        console.log('🚨 EMERGENCY RESPONSE:', emergencyResponse);
                        const emergencyData = emergencyResponse.data;
                        
                        if (emergencyData.success && emergencyData.session) {
                            console.log('✅ EMERGENCY RECOVERY SUCCESS - Processing data...');
                            this.sessionData = emergencyData.session;
                            this.photos = emergencyData.photos || [];
                            
                            // Set freemium policy directly from API response
                            this.policy = {
                                mode: 'freemium',
                                pricePerPhoto: parseFloat(this.sessionData.pricePerDownload || 4.66),
                                freeCount: parseInt(this.sessionData.freeDownloads || 2),
                                screenshotProtection: true
                            };
                            
                            console.log('✅ EMERGENCY POLICY SET:', this.policy);
                            console.log('✅ EMERGENCY PHOTOS LOADED:', this.photos.length);
                            
                            // Force render the gallery
                            this.displayPhotos();
                            document.getElementById('loadingContainer').style.display = 'none';
                            if (this.photos.length > 0) {
                                document.getElementById('galleryActions').style.display = 'flex';
                                document.getElementById('floatingCart').style.display = 'flex';
                            }
                            
                            console.log('🎉 EMERGENCY RECOVERY COMPLETE - Gallery should now show freemium buttons!');
                            return; // Exit successful recovery
                        }
                    } catch (emergencyError) {
                        console.error('💥 EMERGENCY RECOVERY FAILED:', emergencyError);
                    }
                    
                    this.showError(error.message);
                    
                    // Hide loading and show error
                    document.getElementById('loadingContainer').style.display = 'none';
                    document.getElementById('errorContainer').style.display = 'block';
                }
            }
            
            async loadPolicy() {
                // Policy information is now included in the session data from verification
                // Build policy object from session data
                if (this.sessionData) {
                    // Map pricing model to policy mode
                    let mode = 'free';
                    const pricingModel = this.sessionData.pricingModel || this.sessionData.pricing_model;
                    console.log('🔍 Pricing model from session data:', pricingModel);
                    switch (pricingModel) {
                        case 'free':
                            mode = 'free';
                            break;
                        case 'paid':
                        case 'fixed':
                            mode = 'fixed';
                            break;
                        case 'freemium':
                            mode = 'freemium';
                            break;
                        case 'per_photo':
                            mode = 'per_photo';
                            break;
                        default:
                            mode = 'free';
                    }
                    
                    this.policy = {
                        mode: mode,
                        pricePerPhoto: parseFloat(this.sessionData.pricePerDownload || this.sessionData.price_per_download || 0) || 0,
                        freeCount: parseInt(this.sessionData.freeDownloads || this.sessionData.free_downloads || 0, 10) || 0,
                        screenshotProtection: true // Enable by default for previews
                    };
                    
                    console.log('📋 Built policy from session data:', this.policy);
                    console.log('🐛 DEBUG: Raw session data for policy:', {
                        pricingModel: pricingModel,
                        pricePerDownload: this.sessionData.pricePerDownload,
                        freeDownloads: this.sessionData.freeDownloads,
                        parsedPricePerPhoto: this.policy.pricePerPhoto,
                        parsedFreeCount: this.policy.freeCount
                    });
                    
                    // CRITICAL DEBUG: Make absolutely sure freemium is detected
                    if (pricingModel === 'freemium') {
                        console.log('✅✅✅ FREEMIUM MODE CONFIRMED - Should show immediate download buttons!');
                        console.log('📥 First', this.policy.freeCount, 'photos should show FREE buttons');
                        console.log('💵 Remaining photos should show $' + this.policy.pricePerPhoto.toFixed(2) + ' buttons');
                    } else {
                        console.log('❌❌❌ NOT IN FREEMIUM MODE - Will show Add to Cart buttons');
                        console.log('❌ Current mode:', mode, 'from pricingModel:', pricingModel);
                    }
                    
                    // Update screenshot protection settings
                    if (this.protection && this.policy.screenshotProtection !== undefined) {
                        this.protection.toggleProtection(this.policy.screenshotProtection);
                        console.log(`🛡️ Screenshot protection ${this.policy.screenshotProtection ? 'enabled' : 'disabled'} from policy`);
                    }
                } else {
                    // Fallback if no session data
                    this.policy = { mode: 'free', screenshotProtection: true };
                    console.log('📋 Using fallback free policy');
                }
            }
            
            updateGalleryUI() {
                // Update header
                document.getElementById('galleryTitle').textContent = 
                    this.sessionData.sessionName || 'Photo Gallery';
                document.getElementById('gallerySubtitle').textContent = 
                    `${this.sessionData.clientName || ''} - ${new Date(this.sessionData.sessionDate).toLocaleDateString()}`;
                
                // Update photo count
                document.getElementById('photoCount').textContent = 
                    `${this.photos.length} photo${this.photos.length !== 1 ? 's' : ''}`;
            }
            
            async updatePricingBanner() {
                const banner = document.getElementById('pricingBanner');
                const info = document.getElementById('pricingInfo');
                
                if (!this.policy) {
                    banner.classList.remove('show');
                    return;
                }
                
                // Get real-time status from unified API for accurate quota info
                let quotaInfo = this.currentQuota;
                try {
                    const statusResult = await this.getUnifiedSessionStatus();
                    if (statusResult.success && statusResult.quota) {
                        quotaInfo = statusResult.quota;
                        // Also update policy if it has changed
                        if (statusResult.policy) {
                            this.policy = statusResult.policy;
                        }
                    }
                } catch (error) {
                    console.warn('⚠️ Could not fetch real-time status for banner:', error);
                }
                
                let message = '';
                let bannerClass = 'pricing-banner';
                
                switch (this.policy.mode) {
                    case 'free':
                        message = '✨ ALL PHOTOS ARE FREE TO DOWNLOAD!';
                        bannerClass += ' free-mode';
                        break;
                        
                    case 'fixed':
                    case 'paid':
                        const fixedPrice = parseFloat(this.policy.pricePerPhoto || this.policy.pricePerDownload || 0);
                        message = `💳 PAID GALLERY - $${fixedPrice.toFixed(2)} per photo`;
                        bannerClass += ' paid-mode';
                        break;
                        
                    case 'freemium':
                        const freeCount = parseInt(this.policy.freeCount || 0);
                        const afterPrice = parseFloat(this.policy.pricePerPhoto || this.policy.pricePerDownload || 0);
                        
                        // Use quota info from unified API for accurate remaining count
                        let remaining = 0;
                        if (quotaInfo && quotaInfo.freeRemaining !== undefined) {
                            remaining = quotaInfo.freeRemaining;
                        } else {
                            // Fallback to entitlements calculation
                            const usedFree = this.entitlements.filter(e => !e.orderId || e.orderId === null).length;
                            remaining = Math.max(0, freeCount - usedFree);
                        }
                        
                        console.log(`🔢 FREEMIUM Banner: freeCount=${freeCount}, remaining=${remaining}, afterPrice=${afterPrice}`);
                        
                        if (remaining > 0) {
                            message = `🆓 FREEMIUM - ${remaining} FREE downloads left, then $${afterPrice.toFixed(2)} each`;
                            bannerClass += ' freemium-mode freemium-free';
                        } else {
                            message = `💳 FREE QUOTA USED - Additional photos: $${afterPrice.toFixed(2)} each`;
                            bannerClass += ' freemium-mode freemium-paid';
                        }
                        break;
                        
                    case 'per_photo':
                        message = '💳 PAID GALLERY - Individual pricing per photo';
                        bannerClass += ' paid-mode';
                        break;
                        
                    case 'bulk':
                        if (this.policy.bulkTiers && this.policy.bulkTiers.length > 0) {
                            const firstTier = this.policy.bulkTiers[0];
                            const price = parseFloat(firstTier.price) || 0;
                            const qty = parseInt(firstTier.qty) || 1;
                            message = `📦 BULK PRICING - ${qty}+ photos at $${price.toFixed(2)} each`;
                        } else {
                            message = '📦 BULK PRICING AVAILABLE';
                        }
                        bannerClass += ' bulk-mode';
                        break;
                        
                    default:
                        message = '📥 DOWNLOADS AVAILABLE';
                        bannerClass += ' default-mode';
                }
                
                // Add rate limit warning if applicable
                if (quotaInfo && quotaInfo.rateLimited) {
                    message += ' ⚠️ Rate limit active';
                    bannerClass += ' rate-limited';
                }
                
                info.textContent = message;
                banner.className = bannerClass;
                banner.classList.add('show');
            }
            
            displayPhotos() {
                console.log('🎨 Starting to display photos...');
                const grid = document.getElementById('galleryGrid');
                if (!grid) {
                    console.error('❌ Gallery grid element not found!');
                    return;
                }
                
                console.log(`🎨 Clearing grid and rendering ${this.photos.length} photos`);
                grid.innerHTML = '';
                
                this.photos.forEach((photo, index) => {
                    console.log(`🎨 Creating photo card ${index + 1}/${this.photos.length}:`, photo.filename);
                    try {
                        const photoCard = this.createPhotoCard(photo, index);
                        grid.appendChild(photoCard);
                        console.log(`✅ Photo card ${index + 1} added to grid`);
                    } catch (error) {
                        console.error(`❌ Error creating photo card ${index + 1}:`, error);
                    }
                });
                
                console.log(`🎨 Gallery grid now has ${grid.children.length} photo cards`);
                
                // Apply screenshot protection to all displayed photos
                this.applyProtectionToPhotos();
                console.log('🎨 Photo display complete');
            }
            
            applyProtectionToPhotos() {
                if (!this.protection) return;
                
                // Apply protection to all images based on entitlement status
                document.querySelectorAll('.gallery-photo').forEach(img => {
                    const photoId = img.dataset.photoId;
                    const isEntitled = img.dataset.entitled === 'true';
                    
                    // Only protect unpurchased photos
                    if (!isEntitled) {
                        this.protection.protectImage(img, false);
                    } else {
                        // Mark as purchased for lighter protection
                        this.protection.purchasedPhotos.add(photoId);
                    }
                });
            }
            
            createPhotoCard(photo, index) {
                console.log(`🃏 Creating card for photo ${index + 1}:`, {
                    id: photo.id,
                    filename: photo.filename,
                    url: photo.url,
                    sessionId: this.sessionData?.id
                });
                
                const card = document.createElement('div');
                card.className = 'photo-card';
                card.id = `photo-${index}`;
                
                // Check if photo is in cart
                const inCart = this.cart.some(item => item.photoId === photo.filename);
                if (inCart) {
                    card.classList.add('in-cart');
                }
                console.log(`🃏 Photo ${index + 1} in cart: ${inCart}`);
                
                // Check if photo is already purchased (entitled)
                // Check if photo is already entitled using filename as primary identifier
                const photoIdToCheck = photo.filename;
                const isEntitled = this.entitlements.some(e => 
                    e.photoId === photo.filename ||     // Primary: filename match
                    e.photoId === photo.id ||           // Legacy: photo.id match
                    e.photoId === index.toString() ||   // Legacy: index match for compatibility
                    e.photoUrl === photo.url            // Fallback: URL-based match
                );
                console.log(`🃏 Photo ${index + 1} (photoId: ${photoIdToCheck}) entitled: ${isEntitled}`, {
                    availableEntitlements: this.entitlements.map(e => ({ photoId: e.photoId, photoUrl: e.photoUrl })),
                    checkingFor: { photoId: photo.id, index: index.toString(), filename: photo.filename, url: photo.url }
                });
                
                // 🐛 DEBUG: Log policy and freemium button logic
                console.log(`🐛 DEBUG Photo ${index + 1} Button Logic:`, {
                    isEntitled: isEntitled,
                    policy: this.policy,
                    policyMode: this.policy?.mode,
                    isFreemium: this.policy && this.policy.mode === 'freemium',
                    willShowFreemiumButton: !isEntitled && this.policy && this.policy.mode === 'freemium'
                });
                
                // Calculate price for this photo
                const price = this.calculatePhotoPrice(index);
                console.log(`🃏 Photo ${index + 1} price: ${price}`);
                
                // Generate preview URL using the new preview API
                const filename = photo.filename || photo.name || `photo-${index}.jpg`;
                const previewUrl = `/api/preview/${this.sessionData.id}/${encodeURIComponent(filename)}?token=${this.galleryToken}`;
                console.log(`🃏 Photo ${index + 1} preview URL: ${previewUrl}`);
                
                card.innerHTML = `
                    <div class="photo-wrapper">
                        <img src="${previewUrl}" 
                             alt="${photo.filename}" 
                             loading="lazy"
                             data-photo-id="${photo.filename}"
                             data-entitled="${isEntitled}"
                             data-price="${price}"
                             data-original-url="${photo.url}"
                             class="gallery-photo ${!isEntitled ? 'unpurchased' : 'purchased'}"
                             onerror="console.error('❌ Failed to load image:', this.src)"
                             onload="console.log('✅ Image loaded:', this.src)">
                        ${!isEntitled && price !== null ? `
                            <div class="price-badge ${price === 0 ? 'free' : 'paid'}">
                                ${price === 0 ? 'FREE' : `$${price.toFixed(2)}`}
                            </div>
                        ` : ''}
                    </div>
                    <div class="photo-info">
                        <p class="photo-filename">${photo.filename || `Photo ${index + 1}`}</p>
                        <div class="photo-actions">
                            ${isEntitled ? `
                                <button class="photo-btn download-btn" onclick="galleryCart.downloadPhoto('${photo.filename}', '${photo.url}', '${photo.filename}')">
                                    📥 Download
                                </button>
                            ` : `
                                ${this.policy && this.policy.mode === 'free' ? `
                                    <!-- Free gallery - immediate download -->
                                    <button class="photo-btn download-btn immediate free" 
                                            onclick="galleryCart.downloadPhotoImmediately(event, '${photo.filename}', '${photo.url}', '${photo.filename}', 0)">
                                        📥 FREE Download
                                    </button>
                                ` : this.policy && this.policy.mode === 'freemium' ? `
                                    <!-- Show both FREE and purchase buttons side by side in freemium mode -->
                                    <button class="photo-btn download-btn immediate free ${price === 0 ? '' : 'quota-exhausted'}" 
                                            onclick="galleryCart.downloadPhotoImmediately(event, '${photo.filename}', '${photo.url}', '${photo.filename}', ${price})"
                                            ${price !== 0 ? 'disabled title="Free quota exhausted"' : ''}>
                                        📥 FREE ${price === 0 ? '' : '(0 left)'}
                                    </button>
                                    <button class="photo-btn add-to-cart-btn ${inCart ? 'in-cart' : ''}" 
                                            onclick="galleryCart.toggleCartItem('${photo.filename}', '${photo.url}', '${photo.filename}', ${index})">
                                        ${inCart ? '✓ Added - Remove' : `🛒 $${price !== null && price > 0 ? price.toFixed(2) : '4.75'}`}
                                    </button>
                                ` : `
                                    <button class="photo-btn add-to-cart-btn ${inCart ? 'in-cart' : ''}" 
                                            onclick="galleryCart.toggleCartItem('${photo.filename}', '${photo.url}', '${photo.filename}', ${index})">
                                        ${inCart ? '✓ Added - Remove' : `🛒 Add to Cart - $${price ? price.toFixed(2) : '4.75'}`}
                                    </button>
                                `}
                            `}
                        </div>
                    </div>
                `;
                
                console.log(`🃏 Photo card ${index + 1} created successfully`);
                return card;
            }
            
            calculatePhotoPrice(photoIndex) {
                if (!this.policy) {
                    console.log(`💰 Photo ${photoIndex + 1}: No policy, returning null`);
                    return null;
                }
                
                console.log(`💰 Photo ${photoIndex + 1}: Calculating price with policy:`, {
                    mode: this.policy.mode,
                    pricePerPhoto: this.policy.pricePerPhoto,
                    freeCount: this.policy.freeCount
                });
                
                switch (this.policy.mode) {
                    case 'free':
                        console.log(`💰 Photo ${photoIndex + 1}: FREE mode, returning 0`);
                        return 0;
                        
                    case 'fixed':
                    case 'per_photo':
                        const fixedPrice = parseFloat(this.policy.pricePerPhoto || 0);
                        console.log(`💰 Photo ${photoIndex + 1}: FIXED mode, returning ${fixedPrice}`);
                        return fixedPrice;
                        
                    case 'freemium':
                        const freeCount = parseInt(this.policy.freeCount || 0);
                        
                        // CRITICAL FIX: Count how many free downloads have ACTUALLY been completed
                        // Only count ACTIVE entitlements (completed downloads), NOT cart reservations
                        let totalFreeDownloadsUsed = 0;
                        
                        // Count the number of photos in ACTIVE free entitlements (actually completed downloads)
                        for (const entitlement of this.entitlements) {
                            // Only count active entitlements (completed downloads) for quota calculation
                            if ((!entitlement.orderId || entitlement.orderId === null) && entitlement.isActive === true) {
                                // This is a completed free download (not a cart reservation)
                                if (entitlement.photoIds && Array.isArray(entitlement.photoIds)) {
                                    totalFreeDownloadsUsed += entitlement.photoIds.length;
                                } else {
                                    // Fallback: count the entitlement itself
                                    totalFreeDownloadsUsed++;
                                }
                            }
                        }
                        
                        // Check if THIS specific photo is already entitled (already downloaded)
                        const isPhotoAlreadyEntitled = this.entitlements.some(e => {
                            // Check if this photo is in the entitlement's photoIds array
                            if (e.photoIds && Array.isArray(e.photoIds)) {
                                return e.photoIds.includes(String(photoIndex)) || 
                                       (this.photos[photoIndex] && e.photoIds.includes(this.photos[photoIndex].id));
                            }
                            // Fallback: check by photoUrl or photoId
                            return (e.photoId === String(photoIndex)) || 
                                   (this.photos[photoIndex] && e.photoUrl === this.photos[photoIndex].url);
                        });
                        
                        // If this photo is already entitled/downloaded, show Download button
                        if (isPhotoAlreadyEntitled) {
                            console.log(`💰 Photo ${photoIndex + 1}: Already entitled, showing as downloaded`);
                            return null; // Will show "Download" button instead of price
                        }
                        
                        // Count how many free items are currently in the cart (not yet downloaded)
                        const freeCartItems = this.cart.filter(item => item.price === 0).length;
                        
                        // Calculate if this photo can be free
                        // User can select photos for free if: (already used free downloads + current free cart items) < freeCount
                        const totalFreeAllocated = totalFreeDownloadsUsed + freeCartItems;
                        const canBeFree = totalFreeAllocated < freeCount;
                        const calculatedPrice = canBeFree ? 0 : parseFloat(this.policy.pricePerPhoto || 0);
                        
                        console.log(`💰 Photo ${photoIndex + 1} FREEMIUM calculation:`, {
                            freeCount: freeCount,
                            totalFreeDownloadsUsed: totalFreeDownloadsUsed,
                            freeCartItems: freeCartItems,
                            totalFreeAllocated: totalFreeAllocated,
                            canBeFree: canBeFree,
                            calculatedPrice: calculatedPrice,
                            isAlreadyEntitled: isPhotoAlreadyEntitled
                        });
                        
                        return calculatedPrice;
                        
                    case 'bulk':
                        // Calculate based on current cart size
                        const cartSize = this.cart.length + 1; // Including this photo
                        if (this.policy.bulkTiers) {
                            // Find applicable tier
                            let applicableTier = null;
                            for (const tier of this.policy.bulkTiers.sort((a, b) => b.qty - a.qty)) {
                                if (cartSize >= tier.qty) {
                                    applicableTier = tier;
                                    break;
                                }
                            }
                            return applicableTier ? parseFloat(applicableTier.price) : parseFloat(this.policy.pricePerPhoto || 0);
                        }
                        return parseFloat(this.policy.pricePerPhoto || 0);
                        
                    default:
                        return null;
                }
            }
            
            toggleCartItem(photoId, photoUrl, filename, index) {
                const inCart = this.cart.some(item => item.photoId === photoId);
                
                if (inCart) {
                    this.removeFromCart(photoId);
                } else {
                    const price = this.calculatePhotoPrice(index);
                    this.addToCart(photoId, photoUrl, filename, price);
                }
            }
            
            async addToCart(photoId, photoUrl, filename, price) {
                // Check if already in cart
                if (this.cart.some(item => item.photoId === photoId)) {
                    return;
                }

                try {
                    // Show loading state on the button
                    const cards = document.querySelectorAll('.photo-card');
                    let targetCard = null;
                    cards.forEach((card) => {
                        const photoIndex = card.id.replace('photo-', '');
                        const photo = this.photos[photoIndex];
                        if (photo && (photo.id === photoId || photoIndex === photoId)) {
                            targetCard = card;
                        }
                    });

                    const btn = targetCard?.querySelector('.add-to-cart-btn');
                    const originalText = btn?.textContent;
                    if (btn) {
                        btn.disabled = true;
                        btn.textContent = 'Checking quota...';
                    }

                    // Call server API to validate quota and reserve slot
                    const response = await fetch(`${this.getApiBaseUrl()}/api/downloads/cart/add-item`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            sessionId: this.sessionData.id,
                            clientKey: this.getClientKey(),
                            photoId: photoId,
                            photoUrl: photoUrl,
                            filename: filename || `Photo ${photoId}`
                        })
                    });

                    const data = await response.json();

                    if (data.success) {
                        // Server validated quota - now add to local cart
                        this.cart.push({
                            photoId,
                            photoUrl,
                            filename: filename || `Photo ${photoId}`,
                            price: price || 0,
                            reservationId: data.reservationId // Track server reservation
                        });
                        
                        this.saveCart();
                        this.updateCartUI();
                        this.updatePhotoCard(photoId, true);
                        this.showSuccess('Photo added to cart!');
                        
                        // Update quota display with server response
                        this.updateQuotaDisplay(data.quota);
                        
                        // Recalculate all prices for freemium/bulk modes
                        if (this.policy.mode === 'freemium' || this.policy.mode === 'bulk') {
                            this.recalculatePrices();
                        }
                    } else {
                        // Handle quota exceeded or other errors
                        if (data.quotaExceeded) {
                            this.showQuotaExceededError(data.error, data.quota);
                        } else if (data.alreadyPurchased) {
                            this.showError('This photo has already been purchased.');
                        } else {
                            this.showError(data.error || 'Failed to add photo to cart');
                        }
                        
                        // Update quota display even on failure to show current state
                        if (data.quota) {
                            this.updateQuotaDisplay(data.quota);
                        }
                    }

                } catch (error) {
                    console.error('Error adding photo to cart:', error);
                    this.showError('Network error. Please check your connection and try again.');
                } finally {
                    // Reset button state
                    const cards = document.querySelectorAll('.photo-card');
                    cards.forEach((card) => {
                        const photoIndex = card.id.replace('photo-', '');
                        const photo = this.photos[photoIndex];
                        if (photo && (photo.id === photoId || photoIndex === photoId)) {
                            const btn = card.querySelector('.add-to-cart-btn');
                            if (btn) {
                                btn.disabled = false;
                                // Check if item was actually added to cart
                                const inCart = this.cart.some(item => item.photoId === photoId);
                                btn.textContent = inCart ? '✓ Added - Remove' : '🛒 Add to Cart';
                            }
                        }
                    });
                }
            }
            
            async removeFromCart(photoId) {
                // Find the cart item to get reservation ID
                const cartItem = this.cart.find(item => item.photoId === photoId);
                if (!cartItem) {
                    return; // Item not in cart
                }

                try {
                    // Call server API to release quota reservation
                    const response = await fetch(`${this.getApiBaseUrl()}/api/downloads/cart/remove-item`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            sessionId: this.sessionData.id,
                            clientKey: this.getClientKey(),
                            photoId: photoId
                        })
                    });

                    const data = await response.json();

                    if (data.success || response.status === 404) {
                        // Remove from local cart (allow removal even if server reservation not found)
                        this.cart = this.cart.filter(item => item.photoId !== photoId);
                        this.saveCart();
                        this.updateCartUI();
                        this.updatePhotoCard(photoId, false);
                        
                        // Update quota display with server response
                        if (data.quota) {
                            this.updateQuotaDisplay(data.quota);
                        }
                        
                        // Recalculate all prices for freemium/bulk modes
                        if (this.policy.mode === 'freemium' || this.policy.mode === 'bulk') {
                            this.recalculatePrices();
                        }
                    } else {
                        console.error('Failed to release server reservation:', data.error);
                        // Still remove from local cart to avoid inconsistency
                        this.cart = this.cart.filter(item => item.photoId !== photoId);
                        this.saveCart();
                        this.updateCartUI();
                        this.updatePhotoCard(photoId, false);
                        
                        if (this.policy.mode === 'freemium' || this.policy.mode === 'bulk') {
                            this.recalculatePrices();
                        }
                    }

                } catch (error) {
                    console.error('Error removing photo from cart:', error);
                    // Remove from local cart even if server call fails to avoid inconsistency
                    this.cart = this.cart.filter(item => item.photoId !== photoId);
                    this.saveCart();
                    this.updateCartUI();
                    this.updatePhotoCard(photoId, false);
                    
                    if (this.policy.mode === 'freemium' || this.policy.mode === 'bulk') {
                        this.recalculatePrices();
                    }
                }
            }
            
            recalculatePrices() {
                // Recalculate prices for all items in cart based on current policy
                this.cart.forEach((item, index) => {
                    const photoIndex = this.photos.findIndex(p => p.id === item.photoId || 
                                                                  this.photos.indexOf(p).toString() === item.photoId);
                    if (photoIndex !== -1) {
                        item.price = this.calculatePhotoPrice(photoIndex);
                    }
                });
                
                this.saveCart();
                this.updateCartUI();
                this.displayPhotos(); // Refresh price badges
            }
            
            updatePhotoCard(photoId, inCart) {
                const cards = document.querySelectorAll('.photo-card');
                cards.forEach((card) => {
                    const photoIndex = card.id.replace('photo-', '');
                    const photo = this.photos[photoIndex];
                    if (photo && (photo.id === photoId || photoIndex === photoId)) {
                        if (inCart) {
                            card.classList.add('in-cart');
                        } else {
                            card.classList.remove('in-cart');
                        }
                        
                        // Update button text
                        const btn = card.querySelector('.add-to-cart-btn');
                        if (btn) {
                            btn.textContent = inCart ? '✓ Added - Remove' : '🛒 Add to Cart';
                            btn.classList.toggle('in-cart', inCart);
                        }
                    }
                });
            }
            
            updateCartUI() {
                const cartCount = document.getElementById('cartCount');
                const cartItems = document.getElementById('cartItems');
                const cartTotal = document.getElementById('cartTotal');
                const checkoutBtn = document.getElementById('checkoutBtn');
                
                // Update count
                cartCount.textContent = this.cart.length;
                
                // Update items display
                if (this.cart.length === 0) {
                    cartItems.innerHTML = `
                        <div class="cart-empty">
                            <div class="cart-empty-icon">🛒</div>
                            <h3>Your cart is empty</h3>
                            <p>Add photos to start your collection</p>
                        </div>
                    `;
                    checkoutBtn.disabled = true;
                } else {
                    cartItems.innerHTML = this.cart.map(item => `
                        <div class="cart-item" data-photo-id="${item.photoId}">
                            <div class="cart-item-image">
                                <img src="${item.photoUrl}" alt="${item.filename}">
                            </div>
                            <div class="cart-item-details">
                                <div class="cart-item-name">${item.filename}</div>
                                <div class="cart-item-price">
                                    ${item.price === 0 ? 'FREE' : `$${item.price.toFixed(2)}`}
                                </div>
                            </div>
                            <button class="cart-item-remove" onclick="galleryCart.removeFromCart('${item.photoId}')">
                                ✕
                            </button>
                        </div>
                    `).join('');
                    checkoutBtn.disabled = false;
                }
                
                // Update total
                const total = this.calculateTotal();
                cartTotal.textContent = total === 0 ? 'FREE' : `$${total.toFixed(2)}`;
            }
            
            calculateTotal() {
                return this.cart.reduce((total, item) => total + (item.price || 0), 0);
            }
            
            selectAllPhotos() {
                // Add all photos to cart that aren't already entitled
                this.photos.forEach((photo, index) => {
                    const photoId = photo.id || index.toString();
                    const isEntitled = this.entitlements.some(e => e.photoId === photoId || e.photoUrl === photo.url);
                    const inCart = this.cart.some(item => item.photoId === photoId);
                    
                    if (!isEntitled && !inCart) {
                        const price = this.calculatePhotoPrice(index);
                        this.addToCart(photoId, photo.url, photo.filename, price);
                    }
                });
                
                this.showSuccess('All available photos added to cart!');
            }
            
            async clearCart(silent = false) {
                if (silent || confirm('Are you sure you want to clear your cart?')) {
                    try {
                        // Call server API to clear all reservations
                        await fetch(`${this.getApiBaseUrl()}/api/downloads/cart/clear`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                sessionId: this.sessionData.id,
                                clientKey: this.getClientKey()
                            })
                        });
                    } catch (error) {
                        console.error('Error clearing server cart reservations:', error);
                        // Continue with local clear even if server call fails
                    }

                    this.cart = [];
                    this.saveCart();
                    this.updateCartUI();
                    this.displayPhotos(); // Reset all photo cards
                    this.closeCart();

                    // Refresh quota display
                    await this.loadQuotaStatus();
                }
            }
            
            async proceedToCheckout() {
                const total = this.calculateTotal();
                
                // If total is 0 (all free), process without payment
                if (total === 0) {
                    await this.processFreeDownloads();
                    return;
                }
                
                // Check if we have client email
                if (!this.clientEmail) {
                    this.showEmailModal();
                    return;
                }
                
                // Create checkout session
                await this.createCheckoutSession();
            }
            
            async processFreeDownloads() {
                try {
                    // For free downloads, create entitlements directly
                    const items = this.cart.map(item => ({
                        photoId: item.photoId,
                        photoUrl: item.photoUrl,
                        filename: item.filename
                    }));
                    
                    const response = await fetch(`${this.getApiBaseUrl()}/api/downloads/entitlements`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            sessionId: this.sessionData.id,
                            clientKey: this.getClientKey(),
                            items: items,
                            type: 'free'
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        this.clearCart(true); // Silent clear after successful free downloads
                        this.closeCart();
                        await this.loadEntitlements();
                        this.displayPhotos();
                        this.showSuccess('Free downloads are ready! Click download on each photo.');
                    } else {
                        throw new Error(data.error || 'Failed to process free downloads');
                    }
                    
                } catch (error) {
                    console.error('Error processing free downloads:', error);
                    alert('Failed to process downloads. Please try again.');
                }
            }
            
            async createCheckoutSession() {
                try {
                    // Show loading state
                    const checkoutBtn = document.getElementById('checkoutBtn');
                    const originalText = checkoutBtn.textContent;
                    checkoutBtn.disabled = true;
                    checkoutBtn.textContent = 'Processing...';
                    
                    // Prepare items for checkout
                    const items = this.cart.map(item => item.photoId);
                    
                    const response = await fetch(`${this.getApiBaseUrl()}/api/downloads/checkout`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            sessionId: this.sessionData.id,
                            clientKey: this.clientEmail,
                            clientName: this.clientName,
                            items: items
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (data.success && data.checkoutUrl) {
                        // Redirect to Stripe Checkout
                        window.location.href = data.checkoutUrl;
                    } else {
                        throw new Error(data.error || 'Failed to create checkout session');
                    }
                    
                } catch (error) {
                    console.error('Error creating checkout:', error);
                    alert(`Checkout failed: ${error.message}`);
                    
                    // Reset button
                    const checkoutBtn = document.getElementById('checkoutBtn');
                    checkoutBtn.disabled = false;
                    checkoutBtn.textContent = 'Proceed to Checkout';
                }
            }
            
            async handleCheckoutReturn() {
                if (this.checkoutStatus === 'success') {
                    // Clear cart after successful purchase (silent - no confirmation)
                    this.clearCart(true);
                    
                    // Load entitlements to show purchased items
                    if (this.clientEmail) {
                        await this.loadEntitlements();
                    }
                    
                    // Refresh gallery to show download buttons
                    this.displayPhotos();
                    
                    // Show success message
                    this.showSuccess('Payment successful! Your photos are ready to download.');
                    
                    // Remove URL parameters
                    window.history.replaceState({}, document.title, window.location.pathname);
                    
                } else if (this.checkoutStatus === 'cancel') {
                    // Show message that checkout was cancelled
                    this.showSuccess('Checkout cancelled. Your cart has been saved.');
                    
                    // Remove URL parameters
                    window.history.replaceState({}, document.title, window.location.pathname);
                }
            }
            
            async loadEntitlements() {
                try {
                    if (!this.sessionData) return;
                    
                    // Use same clientKey logic as processFreeDownloads to avoid mismatch
                    const clientKey = this.getClientKey();
                    
                    console.log(`🔍 Loading entitlements for clientKey: ${clientKey}`);
                    
                    const response = await fetch(`${this.getApiBaseUrl()}/api/downloads/entitlements?sessionId=${this.sessionData.id}&clientKey=${clientKey}`);
                    const data = await response.json();
                    
                    if (data.success) {
                        this.entitlements = data.entitlements || [];
                        console.log(`✅ Loaded ${this.entitlements.length} entitlements for ${clientKey}`);
                        
                        // Update pricing banner for freemium mode
                        await this.updatePricingBanner();
                    } else {
                        console.error('Failed to load entitlements:', data.error);
                        this.entitlements = [];
                    }
                    
                } catch (error) {
                    console.error('Error loading entitlements:', error);
                    this.entitlements = [];
                }
            }
            
            async downloadPhoto(photoId, photoUrl, filename) {
                try {
                    console.log(`📥 Processing entitled download for ${filename}`);
                    
                    // Use unified API for processing the download
                    const downloadResult = await this.processUnifiedDownload(photoId, photoUrl, filename, false, null);
                    
                    if (downloadResult.success && downloadResult.downloadToken) {
                        // Trigger download using the token
                        const downloadUrl = `/api/downloads/photo/${downloadResult.downloadToken}`;
                        const link = document.createElement('a');
                        link.href = downloadUrl;
                        link.download = filename || 'photo.jpg';
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        
                        this.showSuccess(`Downloaded ${filename}!`);
                        
                        // Update quota display after successful download
                        await this.updateQuotaFromUnifiedAPI();
                        
                    } else {
                        const errorMessage = downloadResult.error || 'Download processing failed';
                        console.error('❌ Download failed:', errorMessage);
                        
                        // Handle specific error scenarios
                        if (downloadResult.code === 'PAYMENT_REQUIRED' && downloadResult.paymentInfo) {
                            this.handlePaymentRequired(downloadResult.paymentInfo, photoId, photoUrl, filename);
                        } else if (downloadResult.code === 'RATE_LIMIT_EXCEEDED') {
                            this.showError(`Rate limit exceeded. Please wait ${downloadResult.retryAfter || 60} seconds before trying again.`);
                        } else {
                            this.showError(`Download failed: ${errorMessage}`);
                        }
                    }
                } catch (error) {
                    console.error('❌ Error downloading photo:', error);
                    this.showError(`Network error during download: ${error.message}`);
                }
            }
            
            async downloadPhotoImmediately(event, photoId, photoUrl, filename, price) {
                // Capture original text before try block to ensure it's accessible in finally
                const button = event?.target;
                const originalText = button?.textContent || (price === 0 ? '📥 FREE Download' : '📥 Download');
                
                try {
                    console.log(`🚀 Starting immediate download for photo: ${filename} (price: ${price})`);
                    
                    // Show loading state on button
                    if (button) {
                        button.disabled = true;
                        button.textContent = 'Processing...';
                    }
                    
                    // Use unified API for immediate download processing
                    const downloadResult = await this.processUnifiedDownload(photoId, photoUrl, filename, price > 0, null);
                    
                    if (downloadResult.success && downloadResult.downloadToken) {
                        // Trigger download using the token
                        const downloadUrl = `/api/downloads/photo/${downloadResult.downloadToken}`;
                        const link = document.createElement('a');
                        link.href = downloadUrl;
                        link.download = filename || 'photo.jpg';
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        
                        // Update UI to reflect the download
                        await this.loadEntitlements();
                        this.displayPhotos(); // Refresh UI to show updated state
                        
                        // Update quota display
                        await this.updateQuotaFromUnifiedAPI();
                        
                        const successMessage = price === 0 ? 
                            `Downloaded ${filename} for FREE!` : 
                            `Downloaded ${filename} for $${price.toFixed(2)}!`;
                        this.showSuccess(successMessage);
                        
                        // Show pricing info if applicable
                        if (downloadResult.pricing) {
                            console.log('💰 Download pricing info:', downloadResult.pricing);
                            await this.updatePricingBanner();
                        }
                        
                    } else {
                        const errorMessage = downloadResult.error || 'Download processing failed';
                        console.error('❌ Immediate download failed:', errorMessage);
                        
                        // Handle specific error scenarios with better UX
                        if (downloadResult.code === 'PAYMENT_REQUIRED' && downloadResult.paymentInfo) {
                            this.handlePaymentRequired(downloadResult.paymentInfo, photoId, photoUrl, filename);
                        } else if (downloadResult.code === 'RATE_LIMIT_EXCEEDED') {
                            this.showError(`Too many requests. Please wait ${downloadResult.retryAfter || 60} seconds before trying again.`);
                        } else if (downloadResult.code === 'QUOTA_EXCEEDED') {
                            // Auto-add to cart when quota exceeded
                            console.log('🛒 Free quota exceeded, automatically adding to cart...');
                            const paidPrice = this.policy?.pricePerPhoto ? parseFloat(this.policy.pricePerPhoto) : 4.75;
                            await this.addToCart(photoId, photoUrl, filename, paidPrice);
                            this.showSuccess(`Free quota exhausted! Added ${filename} to cart for $${paidPrice.toFixed(2)}`);
                            await this.updatePricingBanner();
                            this.displayPhotos();
                            return; // Exit successfully
                        } else {
                            this.showError(`Download failed: ${errorMessage}`);
                        }
                    }
                } catch (error) {
                    console.error('❌ Error in immediate download:', error);
                    this.showError(`Network error during download: ${error.message}`);
                } finally {
                    // Reset button state
                    if (event && event.target) {
                        event.target.disabled = false;
                        event.target.textContent = originalText || (price === 0 ? '📥 FREE Download' : '📥 Download');
                    }
                }
            }
            
            // UI Helper Methods
            openCart() {
                document.getElementById('cartDrawer').classList.add('open');
                document.getElementById('cartOverlay').classList.add('show');
                document.body.style.overflow = 'hidden';
            }
            
            closeCart() {
                document.getElementById('cartDrawer').classList.remove('open');
                document.getElementById('cartOverlay').classList.remove('show');
                document.body.style.overflow = '';
            }
            
            showEmailModal() {
                document.getElementById('emailModal').classList.add('show');
                
                // Pre-fill if we have saved info
                if (this.clientEmail) {
                    document.getElementById('clientEmail').value = this.clientEmail;
                }
                if (this.clientName) {
                    document.getElementById('clientName').value = this.clientName;
                }
            }
            
            closeEmailModal() {
                document.getElementById('emailModal').classList.remove('show');
            }
            
            handleEmailSubmit(e) {
                e.preventDefault();
                
                this.clientEmail = document.getElementById('clientEmail').value;
                this.clientName = document.getElementById('clientName').value;
                
                // Save client info
                this.saveClientInfo();
                
                // Close modal and proceed with checkout
                this.closeEmailModal();
                this.createCheckoutSession();
            }
            
            showSuccess(message) {
                const successMessage = document.getElementById('successMessage');
                const successText = document.getElementById('successText');
                
                successText.textContent = message;
                successMessage.classList.add('show');
                
                setTimeout(() => {
                    successMessage.classList.remove('show');
                }, 3000);
            }
            
            showError(message, errorType = 'general') {
                console.error(`🚨 Error [${errorType}]:`, message);
                
                // Show error in the error container
                document.getElementById('loadingContainer').style.display = 'none';
                document.getElementById('errorContainer').style.display = 'block';
                document.getElementById('errorMessage').textContent = message;
                
                // Also show as a temporary toast notification
                this.showToast(message, 'error', errorType);
            }

            /**
             * Enhanced toast notification system
             */
            showToast(message, type = 'info', category = '') {
                const toastId = 'toast-' + Date.now();
                const iconMap = {
                    'success': '✅',
                    'error': '❌',
                    'warning': '⚠️',
                    'info': 'ℹ️',
                    'rate-limit': '🕐',
                    'network-error': '🌐',
                    'quota-exceeded': '📊'
                };
                
                const icon = iconMap[type] || iconMap[category] || iconMap['info'];
                
                const toast = document.createElement('div');
                toast.id = toastId;
                toast.className = `toast toast-${type} ${category ? `toast-${category}` : ''}`;
                toast.innerHTML = `
                    <span class="toast-icon">${icon}</span>
                    <span class="toast-message">${message}</span>
                    <button class="toast-close" onclick="this.parentElement.remove()">×</button>
                `;
                
                // Add to toast container or create one
                let toastContainer = document.getElementById('toastContainer');
                if (!toastContainer) {
                    toastContainer = document.createElement('div');
                    toastContainer.id = 'toastContainer';
                    toastContainer.className = 'toast-container';
                    document.body.appendChild(toastContainer);
                }
                
                toastContainer.appendChild(toast);
                
                // Auto-remove after delay based on message type
                const delays = {
                    'success': 3000,
                    'info': 4000,
                    'warning': 6000,
                    'error': 8000,
                    'rate-limit': 10000
                };
                
                const delay = delays[type] || delays[category] || 5000;
                
                setTimeout(() => {
                    const toastEl = document.getElementById(toastId);
                    if (toastEl) {
                        toastEl.classList.add('toast-fade-out');
                        setTimeout(() => toastEl.remove(), 300);
                    }
                }, delay);
            }

            // ========================================
            // QUOTA MANAGEMENT METHODS
            // ========================================

            updateQuotaDisplay(quotaInfo) {
                const quotaContainer = document.getElementById('quotaInfo');
                if (!quotaInfo) {
                    quotaContainer.style.display = 'none';
                    return;
                }

                // Show/hide quota info based on quota limits and pricing mode
                if (quotaInfo.unlimited || (!quotaInfo.limit && quotaInfo.limit !== 0)) {
                    quotaContainer.style.display = 'none';
                    return;
                }

                quotaContainer.style.display = 'block';
                
                const quotaText = document.getElementById('quotaText');
                const quotaProgress = document.getElementById('quotaProgress');
                const quotaBar = document.getElementById('quotaBar');

                // Enhanced quota info with unified API support
                const remaining = quotaInfo.remaining || quotaInfo.freeRemaining || 0;
                const total = quotaInfo.limit || quotaInfo.freeTotal || 0;
                const used = quotaInfo.used || 0;
                const reserved = quotaInfo.reserved || quotaInfo.cartReserved || 0;
                
                // Handle freemium mode differently
                let quotaMessage = '';
                if (this.policy?.mode === 'freemium') {
                    const freeRemaining = quotaInfo.freeRemaining || 0;
                    const freeTotal = quotaInfo.freeTotal || this.policy.freeCount || 0;
                    const reservedText = reserved > 0 ? ` (${reserved} in cart)` : '';
                    
                    if (freeRemaining > 0) {
                        quotaMessage = `🆓 ${freeRemaining} of ${freeTotal} FREE downloads remaining${reservedText}`;
                    } else {
                        quotaMessage = `💳 Free quota used - paid downloads only${reservedText}`;
                    }
                } else {
                    // Standard quota display for other modes
                    const reservedText = reserved > 0 ? ` (${reserved} in cart)` : '';
                    quotaMessage = `${remaining} of ${total} downloads remaining${reservedText}`;
                }
                
                // Add rate limiting info if applicable
                if (quotaInfo.rateLimited) {
                    const retryAfter = quotaInfo.retryAfter || 60;
                    quotaMessage += ` ⚠️ Rate limited (${retryAfter}s)`;
                }
                
                quotaText.textContent = quotaMessage;

                // Update progress bar with enhanced visual feedback
                if (total > 0) {
                    const percentage = Math.max(0, (remaining / total) * 100);
                    quotaBar.style.width = `${percentage}%`;
                    
                    // Enhanced color coding based on remaining quota and mode
                    quotaBar.className = 'quota-bar';
                    if (percentage <= 0) {
                        quotaBar.classList.add('quota-exhausted');
                    } else if (percentage <= 10) {
                        quotaBar.classList.add('quota-critical');
                    } else if (percentage <= 25) {
                        quotaBar.classList.add('quota-warning');
                    } else if (percentage <= 50) {
                        quotaBar.classList.add('quota-medium');
                    } else {
                        quotaBar.classList.add('quota-good');
                    }
                    
                    // Add special styling for freemium mode
                    if (this.policy?.mode === 'freemium') {
                        quotaBar.classList.add('quota-freemium');
                    }
                } else {
                    // Handle unlimited or no-limit scenarios
                    quotaBar.style.width = '100%';
                    quotaBar.className = 'quota-bar quota-unlimited';
                }

                // Store quota info for use in other methods
                this.currentQuota = quotaInfo;
            }

            showQuotaExceededError(message, quotaInfo) {
                // Create a more detailed error modal for quota exceeded
                const modal = document.createElement('div');
                modal.className = 'quota-modal-overlay';
                modal.innerHTML = `
                    <div class="quota-modal">
                        <div class="quota-modal-header">
                            <h3>⚠️ Download Limit Reached</h3>
                        </div>
                        <div class="quota-modal-body">
                            <p>${message}</p>
                            ${quotaInfo ? `
                                <div class="quota-details">
                                    <p><strong>Your Current Usage:</strong></p>
                                    <ul>
                                        <li>Used: ${quotaInfo.used || 0} downloads</li>
                                        <li>Limit: ${quotaInfo.total || 0} downloads</li>
                                        <li>Remaining: ${quotaInfo.remaining || 0} downloads</li>
                                    </ul>
                                </div>
                            ` : ''}
                            <p>Remove items from your cart or complete your purchase to continue.</p>
                        </div>
                        <div class="quota-modal-actions">
                            <button class="quota-modal-btn primary" onclick="this.closest('.quota-modal-overlay').remove()">
                                OK
                            </button>
                        </div>
                    </div>
                `;

                document.body.appendChild(modal);

                // Auto-remove after 8 seconds
                setTimeout(() => {
                    if (modal.parentNode) {
                        modal.remove();
                    }
                }, 8000);
            }

            async loadQuotaStatus() {
                try {
                    if (!this.sessionData?.id || !this.galleryToken) {
                        console.warn('⚠️ Cannot load quota status: missing session data or gallery token');
                        return;
                    }

                    // Use unified API for quota status
                    const statusResult = await this.getUnifiedSessionStatus();

                    if (statusResult.success && statusResult.quota) {
                        this.updateQuotaDisplay(statusResult.quota);
                        
                        // Also update policy if provided
                        if (statusResult.policy) {
                            this.policy = statusResult.policy;
                        }
                        
                        // Update entitlements if provided
                        if (statusResult.entitlements) {
                            this.entitlements = statusResult.entitlements;
                        }
                    } else {
                        console.warn('⚠️ Failed to load quota status:', statusResult.error);
                    }
                } catch (error) {
                    console.error('❌ Error loading quota status:', error);
                }
            }

            /**
             * Helper method to update quota display from unified API
             */
            async updateQuotaFromUnifiedAPI() {
                try {
                    const statusResult = await this.getUnifiedSessionStatus();
                    if (statusResult.success && statusResult.quota) {
                        this.updateQuotaDisplay(statusResult.quota);
                        await this.updatePricingBanner();
                    }
                } catch (error) {
                    console.error('❌ Error updating quota from unified API:', error);
                }
            }

            /**
             * Enhanced error handling with retry mechanisms
             */
            async makeUnifiedApiCall(apiCall, retries = 3, delay = 1000) {
                for (let attempt = 1; attempt <= retries; attempt++) {
                    try {
                        const result = await apiCall();
                        if (result.success) {
                            return result;
                        }
                        
                        // Handle specific error codes
                        if (result.code === 'RATE_LIMIT_EXCEEDED' && attempt < retries) {
                            const retryAfter = result.retryAfter || delay;
                            console.log(`🔄 Rate limited, retrying after ${retryAfter}ms (attempt ${attempt}/${retries})`);
                            await this.sleep(retryAfter);
                            continue;
                        }
                        
                        return result; // Return the error result if not retryable
                        
                    } catch (error) {
                        console.error(`❌ API call failed (attempt ${attempt}/${retries}):`, error);
                        
                        // Network errors - retry with exponential backoff
                        if (attempt < retries && (error.name === 'NetworkError' || error.message.includes('fetch'))) {
                            const retryDelay = delay * Math.pow(2, attempt - 1);
                            console.log(`🔄 Network error, retrying after ${retryDelay}ms`);
                            await this.sleep(retryDelay);
                            continue;
                        }
                        
                        return {
                            success: false,
                            error: `Network error: ${error.message}`,
                            code: 'NETWORK_ERROR'
                        };
                    }
                }
                
                return {
                    success: false,
                    error: 'Maximum retries exceeded',
                    code: 'MAX_RETRIES_EXCEEDED'
                };
            }

            /**
             * Utility method for delays
             */
            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            /**
             * Enhanced download with progress tracking
             */
            async downloadWithProgress(photoId, photoUrl, filename, isPaid = false, paymentIntentId = null) {
                const progressIndicator = this.showProgressIndicator(`Processing ${filename}...`);
                
                try {
                    // Use retry mechanism for download processing
                    const result = await this.makeUnifiedApiCall(() => 
                        this.processUnifiedDownload(photoId, photoUrl, filename, isPaid, paymentIntentId)
                    );
                    
                    if (result.success && result.downloadToken) {
                        this.updateProgress(progressIndicator, 'Downloading file...', 80);
                        
                        // Trigger download
                        const downloadUrl = `/api/downloads/photo/${result.downloadToken}`;
                        const link = document.createElement('a');
                        link.href = downloadUrl;
                        link.download = filename;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        
                        this.updateProgress(progressIndicator, 'Download complete!', 100);
                        setTimeout(() => this.hideProgressIndicator(progressIndicator), 1000);
                        
                        // Update quota display
                        await this.updateQuotaFromUnifiedAPI();
                        
                        return { success: true };
                        
                    } else {
                        this.hideProgressIndicator(progressIndicator);
                        this.handleDownloadError(result, photoId, photoUrl, filename);
                        return result;
                    }
                } catch (error) {
                    this.hideProgressIndicator(progressIndicator);
                    console.error('❌ Download with progress failed:', error);
                    this.showError(`Download failed: ${error.message}`);
                    return { success: false, error: error.message };
                }
            }

            /**
             * Show progress indicator
             */
            showProgressIndicator(message) {
                const progressId = 'progress-' + Date.now();
                const progressHtml = `
                    <div id="${progressId}" class="progress-indicator">
                        <div class="progress-content">
                            <div class="progress-spinner"></div>
                            <div class="progress-message">${message}</div>
                            <div class="progress-bar">
                                <div class="progress-fill" style="width: 10%"></div>
                            </div>
                        </div>
                    </div>
                `;
                
                document.body.insertAdjacentHTML('beforeend', progressHtml);
                return progressId;
            }

            /**
             * Update progress indicator
             */
            updateProgress(progressId, message, percentage) {
                const indicator = document.getElementById(progressId);
                if (indicator) {
                    const messageEl = indicator.querySelector('.progress-message');
                    const fillEl = indicator.querySelector('.progress-fill');
                    if (messageEl) messageEl.textContent = message;
                    if (fillEl) fillEl.style.width = `${percentage}%`;
                }
            }

            /**
             * Hide progress indicator
             */
            hideProgressIndicator(progressId) {
                const indicator = document.getElementById(progressId);
                if (indicator) {
                    indicator.remove();
                }
            }

            /**
             * Enhanced error handling for downloads
             */
            handleDownloadError(result, photoId, photoUrl, filename) {
                const errorCode = result.code;
                const errorMessage = result.error || 'Download failed';
                
                switch (errorCode) {
                    case 'PAYMENT_REQUIRED':
                        if (result.paymentInfo) {
                            this.handlePaymentRequired(result.paymentInfo, photoId, photoUrl, filename);
                        } else {
                            this.showError('Payment required for this download. Please add to cart.');
                        }
                        break;
                        
                    case 'RATE_LIMIT_EXCEEDED':
                        const retryAfter = result.retryAfter || 60;
                        this.showError(`Too many requests. Please wait ${retryAfter} seconds before trying again.`, 'rate-limit');
                        break;
                        
                    case 'QUOTA_EXCEEDED':
                        this.handleQuotaExceeded(photoId, photoUrl, filename);
                        break;
                        
                    case 'NETWORK_ERROR':
                        this.showError('Network connection error. Please check your connection and try again.', 'network-error');
                        break;
                        
                    case 'GALLERY_EXPIRED':
                        this.showError('This gallery has expired and downloads are no longer available.', 'gallery-expired');
                        break;
                        
                    case 'INVALID_SESSION':
                        this.showError('Your session has expired. Please refresh the page.', 'session-expired');
                        break;
                        
                    default:
                        this.showError(`Download failed: ${errorMessage}`, 'general-error');
                }
            }

            /**
             * Handle quota exceeded scenarios
             */
            handleQuotaExceeded(photoId, photoUrl, filename) {
                if (this.policy?.mode === 'freemium') {
                    // Auto-add to cart in freemium mode
                    const paidPrice = this.policy?.pricePerPhoto ? parseFloat(this.policy.pricePerPhoto) : 4.75;
                    this.addToCart(photoId, photoUrl, filename, paidPrice);
                    this.showError(`Free quota exhausted! Added ${filename} to cart for $${paidPrice.toFixed(2)}`, 'quota-exceeded');
                    this.updatePricingBanner();
                    this.displayPhotos();
                } else {
                    this.showError('Download quota exceeded. Please upgrade or wait for quota reset.', 'quota-exceeded');
                }
            }

            /**
             * Handle payment required scenarios from unified API
             */
            handlePaymentRequired(paymentInfo, photoId, photoUrl, filename) {
                try {
                    console.log('💳 Payment required for download:', paymentInfo);
                    
                    // Auto-add to cart for payment processing
                    const price = paymentInfo.amount || (this.policy?.pricePerPhoto ? parseFloat(this.policy.pricePerPhoto) : 4.75);
                    this.addToCart(photoId, photoUrl, filename, price);
                    
                    // Show user-friendly message
                    this.showError(`This download requires payment ($${price.toFixed(2)}). Added to cart for checkout.`);
                    
                    // Update UI to show cart
                    this.openCart();
                    
                } catch (error) {
                    console.error('❌ Error handling payment required:', error);
                    this.showError('Payment required - please add photo to cart');
                }
            }
            
            // Storage Methods
            saveCart() {
                localStorage.setItem(`cart_${this.galleryToken}`, JSON.stringify(this.cart));
            }
            
            loadCart() {
                const saved = localStorage.getItem(`cart_${this.galleryToken}`);
                if (saved) {
                    try {
                        this.cart = JSON.parse(saved);
                        console.log(`📦 Loaded ${this.cart.length} items from saved cart`);
                    } catch (error) {
                        console.error('Error loading cart:', error);
                        this.cart = [];
                    }
                }
            }
            
            saveClientInfo() {
                localStorage.setItem('clientEmail', this.clientEmail || '');
                localStorage.setItem('clientName', this.clientName || '');
            }
            
            loadClientInfo() {
                this.clientEmail = localStorage.getItem('clientEmail') || null;
                this.clientName = localStorage.getItem('clientName') || null;
            }
            
            /**
             * Generate or load unique visitor ID for proper quota tracking
             * This ensures each browser tab/visitor gets separate download quotas
             */
            generateUniqueVisitorId() {
                // Try to load existing visitor ID from localStorage
                let visitorId = localStorage.getItem('uniqueVisitorId');
                
                if (!visitorId) {
                    // Generate a new UUID for this visitor
                    visitorId = 'visitor-' + this.generateUUID();
                    localStorage.setItem('uniqueVisitorId', visitorId);
                    console.log(`🆔 Generated new unique visitor ID: ${visitorId}`);
                } else {
                    console.log(`🆔 Loaded existing visitor ID: ${visitorId}`);
                }
                
                this.uniqueVisitorId = visitorId;
            }
            
            /**
             * Generate a random UUID v4
             */
            generateUUID() {
                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                    const r = Math.random() * 16 | 0;
                    const v = c === 'x' ? r : (r & 0x3 | 0x8);
                    return v.toString(16);
                });
            }
            
            /**
             * Get the unique client key for this visitor
             * For freemium galleries, ALWAYS use gallery-session-based key that matches server logic
             */
            getClientKey() {
                // CRITICAL: For freemium mode, ALWAYS use cached gallery client key
                // This ensures consistency with server-side entitlement verification
                if (this.policy && this.policy.mode === 'freemium') {
                    if (this.cachedGalleryClientKey) {
                        return this.cachedGalleryClientKey;
                    } else {
                        console.warn('⚠️ Gallery client key not cached! This will cause entitlement mismatches.');
                        // Emergency fallback - this should not happen if initialization is correct
                        return 'gallery-emergency-fallback';
                    }
                }
                
                // For non-freemium modes (paid downloads), use email if provided, otherwise visitor ID
                return this.clientEmail || this.uniqueVisitorId || 'anonymous';
            }
            
            /**
             * UNIFIED API: Validate gallery access and get session data
             * Uses the new /api/downloads/unified/validate-access endpoint
             */
            async validateUnifiedAccess() {
                try {
                    if (!this.galleryToken) {
                        return {
                            success: false,
                            error: 'No gallery token provided'
                        };
                    }

                    console.log('🔐 Validating access using unified API...');
                    
                    const response = await fetch(`${this.getApiBaseUrl()}/api/downloads/unified/validate-access`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            galleryAccessToken: this.galleryToken
                            // sessionId removed - server will resolve it from the gallery token
                        })
                    });

                    const data = await response.json();

                    if (response.ok && data.success) {
                        console.log('✅ Unified access validation successful');
                        
                        // Store the session data and policy from the unified response
                        this.sessionData = {
                            id: data.session.id,
                            clientName: data.session.clientName,
                            downloadEnabled: data.session.downloadEnabled,
                            galleryExpiresAt: data.session.galleryExpiresAt
                        };
                        
                        this.policy = data.policy;
                        this.cachedGalleryClientKey = data.clientKey;

                        return {
                            success: true,
                            data: {
                                success: true,
                                session: this.sessionData,
                                policy: this.policy,
                                clientKey: data.clientKey,
                                photos: data.photos || [] // Fixed: photos are at root level of API response
                            }
                        };
                    } else {
                        console.error('❌ Unified access validation failed:', data.error);
                        return {
                            success: false,
                            error: data.error || 'Access validation failed',
                            code: data.code
                        };
                    }
                } catch (error) {
                    console.error('❌ Error during unified access validation:', error);
                    return {
                        success: false,
                        error: 'Network error during access validation'
                    };
                }
            }

            /**
             * UNIFIED API: Process download using the new unified endpoint
             */
            async processUnifiedDownload(photoId, photoUrl, filename, isPaid = false, paymentIntentId = null) {
                try {
                    console.log(`🎯 Processing unified download for photo ${photoId}`);
                    
                    const response = await fetch(`${this.getApiBaseUrl()}/api/downloads/unified/process`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            galleryAccessToken: this.galleryToken,
                            sessionId: this.sessionData.id,
                            photoId: photoId,
                            photoUrl: photoUrl,
                            filename: filename,
                            paymentIntentId: paymentIntentId
                        })
                    });

                    const data = await response.json();

                    if (response.ok && data.success) {
                        console.log('✅ Unified download processed successfully');
                        return {
                            success: true,
                            downloadToken: data.downloadToken,
                            expiresIn: data.expiresIn,
                            pricing: data.pricing,
                            watermark: data.watermark
                        };
                    } else {
                        console.error('❌ Unified download processing failed:', data.error);
                        return {
                            success: false,
                            error: data.error || 'Download processing failed',
                            code: data.code,
                            paymentInfo: data.paymentInfo // For payment required scenarios
                        };
                    }
                } catch (error) {
                    console.error('❌ Error during unified download processing:', error);
                    return {
                        success: false,
                        error: 'Network error during download processing'
                    };
                }
            }

            /**
             * UNIFIED API: Get session status and quota information
             */
            async getUnifiedSessionStatus() {
                try {
                    if (!this.sessionData?.id || !this.galleryToken) {
                        throw new Error('Missing session ID or gallery token');
                    }

                    const response = await fetch(`${this.getApiBaseUrl()}/api/downloads/unified/status/${this.sessionData.id}?galleryAccessToken=${encodeURIComponent(this.galleryToken)}&clientKey=${encodeURIComponent(this.cachedGalleryClientKey || '')}`, {
                        method: 'GET'
                    });

                    const data = await response.json();

                    if (response.ok && data.success) {
                        console.log('✅ Session status retrieved successfully');
                        return {
                            success: true,
                            quota: data.quota,
                            policy: data.policy,
                            entitlements: data.entitlements,
                            downloads: data.downloads
                        };
                    } else {
                        console.error('❌ Failed to get session status:', data.error);
                        return {
                            success: false,
                            error: data.error || 'Failed to retrieve session status'
                        };
                    }
                } catch (error) {
                    console.error('❌ Error getting session status:', error);
                    return {
                        success: false,
                        error: 'Network error while checking session status'
                    };
                }
            }

            /**
             * AUTHORITATIVE CLIENT KEY GENERATION
             * Generate client key using IDENTICAL logic to server
             * CRITICAL: Must match server's generateGalleryClientKey function exactly
             */
            async generateGalleryClientKey(galleryAccessToken, sessionId) {
                if (!galleryAccessToken || !sessionId) {
                    throw new Error('Gallery token and session ID are required for client key generation');
                }
                
                // CRITICAL: Use ONLY gallery token + session ID (no IP, no user agent, no other identifiers)
                // This ensures both server and client can generate the exact same key deterministically
                const baseString = `${galleryAccessToken}-${sessionId}`;
                
                // Create a SHA-256 hash for the final client key
                const hashHex = await this.sha256(baseString);
                const clientKey = `gallery-${hashHex.substring(0, 16)}`;
                
                console.log(`🔑 Generated authoritative client key: ${clientKey} for gallery token: ${galleryAccessToken.substring(0, 8)}...`);
                
                return clientKey;
            }
            
            /**
             * Simple SHA-256 implementation for client-side key generation
             */
            async sha256(message) {
                // Use Web Crypto API for SHA-256 hashing
                const msgBuffer = new TextEncoder().encode(message);
                const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                return hashHex;
            }
        }
        
        // Initialize cart when page loads
        let galleryCart;
        console.log('🎯 Setting up DOMContentLoaded listener...');
        
        document.addEventListener('DOMContentLoaded', () => {
            console.log('📄 DOM Content Loaded - Initializing gallery...');
            try {
                galleryCart = new ClientGalleryCart();
                console.log('✅ Gallery cart initialized successfully');
            } catch (error) {
                console.error('❌ Failed to initialize gallery cart:', error);
                console.error('❌ Stack trace:', error.stack);
                // Display error on page
                const errorDiv = document.getElementById('errorContainer');
                if (errorDiv) {
                    errorDiv.style.display = 'block';
                    document.getElementById('errorMessage').textContent = 'Failed to initialize gallery: ' + error.message;
                }
            }
        });
        
        // Clean up real-time connections when page unloads
        window.addEventListener('beforeunload', () => {
            if (galleryCart && typeof galleryCart.disconnectRealTimeUpdates === 'function') {
                galleryCart.disconnectRealTimeUpdates();
            }
        });
        
        console.log('🎯 Gallery JavaScript fully loaded');
    </script>
</body>
</html>